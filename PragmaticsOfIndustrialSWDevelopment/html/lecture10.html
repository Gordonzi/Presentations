<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Pragmatics of Industrial Software Development</title>
<!-- metadata -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<meta name="date" content="August 5, 2010" />
<meta name="author" content="Dean Wampler, Ph.D." />
<meta name="company" content="Department of Computer Science,<br/>Loyola University Chicago" />
<meta name="copyright" content="2010 Dean Wampler, All Rights Reserved" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="../ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="../ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="../lib/stylesheets/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="../ui/default/opera.css" type="text/css" media="projection" id="operaFix" />

<link rel="stylesheet" href="../lib/stylesheets/pressie.css" type="text/css" />

<!-- S5 JS -->
<script src="../ui/default/slides.js" type="text/javascript"></script>

<!-- Syntax Highlighter -->
<!-- <link rel="stylesheet"  href="../lib/stylesheets/SyntaxHighlighter.css"></link> -->
<link type="text/css" rel="stylesheet" href="../lib/stylesheets/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../lib/stylesheets/shThemeDefault.css"/>


</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h2>Copyright &copy; 2010 Dean Wampler, All Rights Reserved</h2>
<h2>August 5, 2010</h2>
</div>

</div>


<div class="presentation">
<div class="slide">
<h1>Lecture 10: Functional Programming (FP): Into the Real World</h1>
<p>Functional Programming is the oldest <em>paradigm</em> of software development, yet it has had relatively little penetration outside academia, at least until recently.</p>
</div>
<div class="slide">
<h1>What Is Functional Programming?</h1>
<p>FP treats computation as the application of functions and avoids mutable data.</p>
<p>FP has its roots in mathematics, specifically lambda calculus, a formal system developed in the 1930s to investigate function definition, function application, and recursion. Many functional programming languages can be viewed as elaborations on the lambda calculus.</p>
<p>(Adapted from <a href="http://en.wikipedia.org/wiki/Functional_programming">Wikipedia</a>.)</p>
</div>
<div class="slide">
<h1>State in Functional Programming</h1>
<p>There is a common misconception that functional programs are <em>stateless</em>. If this were true, they could accomplish <em>nothing</em>, except to heat up your computer!</p>
<p>Where object oriented programs (for example) change state by mutating variables, pure functional programmers represent state <em>on the stack</em>.</p>
<p>That is, the values you pass to functions and the values they return represent the current state of the world.</p>
</div>
<div class="slide">
<h1>FP and Mathematics</h1>
<p>How is FP like mathematics?</p>
</div>
<div class="slide">
<h1>Immutability</h1>
<p>Math variables are not, well &#8230; <em>variable</em>.</p>
<p>x = cos(y)<sup>2</sup></p>
<p>When <code>y</code> is chosen, <code>x</code> is <em>fixed</em>.</p>
</div>
<div class="slide">
<h1>Immutability Benefits</h1>
<p>We have seen many cases where mutability is problematic in software:</p>
<ul>
	<li>Multithreaded concurrency.</li>
	<li>Behavior of <code>equals</code> and <code>hashCode</code>.</li>
	<li>Shallow cloning.</li>
</ul>
</div>
<div class="slide">
<h1>No Side Effects</h1>
<p>Note that immutability means there can be no side effects, by definition. This also has important implications for functions:</p>
<p>x = cos(y)<sup>2</sup></p>
<p><strong>All</strong> work done by <code>cos(y)</code> (for example) is returned and assigned to <code>x</code>. there is no global state that is updated.<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></p>
<p>Functions without side effects are called <em>pure.</em></p>
<p><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup> However, a real implementation might update &#8220;invisible&#8221; state like a cache of previously-calculated values.</p>
</div>
<div class="slide">
<h1>Benefits of No Side Effects</h1>
<p>If the work of a function is independent of global state:<br />
<strong>Referentially Transparency:</strong> I can call it <em>anywhere</em> and <em>anytime</em>.<br />
<strong>Correctness:</strong> I can reason about its behavior (e.g., test it) in isolation.<br />
<strong>Memoization:</strong> I can memorize previous invocations with particular arguments and cache the results for faster subsequent invocations.<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></p>
<p><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup> This is the case where I add memoization explicitly, vs. the internal caching noted on the previous slide.</p>
</div>
<div class="slide">
<h1>First Class Functions</h1>
<p>Functions are <em>first class</em> concepts, just like values.</p>
<p>square(z) = z<sup>2</sup><br />
x = square(cos(y))</p>
<p>Note that square takes a <em>value</em>, but the value could be a &#8220;variable&#8221; <em>or</em> a function.</p>
<p>That is, <em>functions are values</em>.</p>
<p>Note: a function that takes other functions as arguments or returns a function value is called a <em>higher-order function</em>.</p>
</div>
<div class="slide">
<h1>Benefits of First Class Functions</h1>
<p><strong>Composition:</strong> Just like object composition, <em>function composition</em> is a rich, <em>generative</em> tool.</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

// Generate a sequence of strings: "2", "4"
(1 to 10) filter (_ % 2 == 0) map (_.toString) take 2
// ...immutable.IndexedSeq[java.lang.String] = Vector(2, 4)
</pre></div>
<p><em>Generative</em> means I can combine pieces to generate new, more complex behaviors.</p>
</div>
<div class="slide">
<h1>Objects as &#8220;First Class Functions&#8221;</h1>
<p>Actually, this is not all that different than what you&#8217;ve done in Java, which doesn&#8217;t have first class functions:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: java,;">

// Pretend FilterFunc and MapFunc are interfaces with 
// apply methods:
FilterFunc even = new FilterFunc { 
  boolean apply(int i) { return i % 2 == 0; }
}
MapFunc stringize = new MapFunc {
  String apply(int i) { return Integer.toString(i); }
}
// Pretend there is a Range type and there are filter and
// map methods that take "*Func" objects, and there is 
// a take method:
new Range(1, 10).filter(even).map(stringize).take(2)
</pre></div>
</div>
<div class="slide">
<h1>Closures as Objects</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

var count = -1
val uniqueFileName: Function1[String, String] = { prefix =&gt;
  count += 1
  prefix + count
}
uniqueFileName("/foo/bar") // =&gt; "/foo/bar/0"
uniqueFileName("/foo/bar") // =&gt; "/foo/bar/1"
uniqueFileName("/foo/bar") // =&gt; "/foo/bar/2"
</pre></div>
<p>Because <code>uniqueFileName</code> is a function that refers to a variable outside its scope (including its argument list), it forms a <em>closure</em>. I.e., it &#8220;closes over&#8221; the variables it references.</p>
<p>Note that the 3 calls behave just like a stateful object.</p>
<p><em>Prototype-based objects are essentially closures</em>. (e.g., JavaScript)</p>
</div>
<div class="slide">
<h1>Imperative vs. Declarative Programming</h1>
<p><strong>Imperative Programming:</strong> Tell the system <em>how</em> to do a computation.<br />
<strong>Declarative Programming:</strong> Tell the system <em>what</em> computation to do.</p>
<p>Declarative programming:</p>
<ul>
	<li>More clearly separates abstraction (the <em>what</em>) from implementation (the <em>how</em>).</li>
	<li>Minimizes writing the <em>how</em>.</li>
	<li>Minimizes <em>visible</em> side effects (therefore, promotes <em>referentially transparent</em>).</li>
</ul>
</div>
<div class="slide">
<h1>FP != Imperative Programming (IP)</h1>
<p>Both have &#8220;functions&#8221;, but FP emphasizes the application of (mathematical) functions, while IP emphasizes state changes. In fact, IP puts no constraints on mutability, side effects, etc. We&#8217;ve already seen in this course how these &#8220;freedoms&#8221; can be problematic.</p>
<p>Note that <span class="caps">OOP</span> and <em>procedural programming</em> (pre-<span class="caps">OOP</span>, e.g., C) are both examples of Imperative Programming.</p>
</div>
<div class="slide">
<h1>Higher-Kinded Types</h1>
<p>Consider constructing an <code>Exception</code>:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val ex = new Exception("This is an exception.")
</pre></div>
<p>Now consider creating a <code>List</code> of <code>Exceptions</code>:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

type ExceptionList = List[Exception]
</pre></div>
<p>We&#8217;ve used Scala&#8217;s way of declaring a <code>type</code>, just like a variable. You can think of it like a type &#8220;alias&#8221;, just like the variable <code>int ONE = 1</code> is an &#8220;alias&#8221; for the value of <code>1</code>.</p>
</div>
<div class="slide">
<h1>Higher-Kinded Types (cont.)</h1>
<p>The example illustrates an analogy; <code>List[A]</code> is a <em>type constructor</em>, used to construct concrete types like <code>List[Exception]</code>, just like the <code>Exception</code> class is used to construct concrete objects.</p>
<p>Because types like <code>List[A]</code> takes a type as an argument, they are called <em>higher-kinded</em> types, analogous to <em>higher-order</em> functions, which take other functions as arguments or return function results.</p>
</div>
<div class="slide">
<h1>Higher-Kinded Types (cont.)</h1>
<p>Why are they useful, because they let us abstract over the details of the &#8220;contained&#8221; type and focus on operations applied to the container itself.</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

def printList(list: List[_]) = list map println
printList(List(1, "two", 3.3))
// =&gt; 1
// =&gt; two
// =&gt; 3.3
</pre></div>
<p>Note that we use the wildcard <code>_</code> for the <code>List[_]</code> parameter, because we don&#8217;t care what it is.<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></p>
<p><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup> Actually, on the <span class="caps">JVM</span> we have no choice, because this type information is <em>erased</em> in the byte code.</p>
</div>
<div class="slide">
<h1>Higher-Kinded Types (cont.)</h1>
<p>Note also the <em>point-free style</em> of the function definition: <code>list map println</code>. It&#8217;s equivalent to this</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

def printList(list: List[_]) = list map (x =&gt; println(x))
</pre></div>
<p>Not having to write &#8220;boilerplate&#8221;, like the <code>x</code> variable simplifies the code and minimizes mistakes. This is also a benefit in Scala of using <em>function application</em>, e.g., <code>foo(x)</code>, vs. object method syntax, e.g., <code>x.foo</code>. For the latter, if <code>println</code> were a method on all objects, we would have to write:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

def printList(list: List[_]) = list map (x =&gt; x.println)
</pre></div>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>Consider this code from <code>InstrumentAnalysisServerSupervisor</code>, which calculates (or retrieves) the desired statistics for the desired instruments (stocks):</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

def calculate (criteria: CriteriaMap) = {
  val futures = // Save a sequence of "futures"
    for {       // "for comprehension"
      instrument &lt;- criteria.instruments // each instrument
      statistic  &lt;- criteria.statistics  // each statistic
      calculator &lt;-       // get an InstrumentAnalysisServer...
        getOrMakeInstrumentAnalysisServerFor(instrument, statistic)
    } yield (    // "yield" the future; goes into sequence
      calculator !!!    // send message to actor, returning future 
        CalculateStatistics(    // message to send...
          criteria.             // criteria ...
            withInstruments(instrument).  // this instrument
            withStatistics(statistic)))   // this statistic
  Futures.awaitAll(futures)    // Wait for all futures to finish
  futuresToJSON(futures, ...)  // convert result to JSON
}
</pre></div>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>Let&#8217;s focus on the <em>for comprehension</em>.</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

for {
  instrument &lt;- criteria.instruments   // iterates through list
  statistic  &lt;- criteria.statistics    // same
  calculator &lt;-  // getOrMake... returns an Option[...]
    getOrMakeInstrumentAnalysisServerFor(instrument, statistic)
} yield (...)
}
</pre></div>
<p>Note that even though <code>Option[A]</code> has 0 or 1 item, it behaves like any other collection. You can &#8220;iterate&#8221; through it, for example.</p>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>Other languages call these constructs <em>list comprehensions</em> or <em>sequence comprehensions</em>; you can &#8220;comprehend&#8221; a collection, process it, generate a new collection, etc.</p>
<p>You don&#8217;t have to worry about loop counters, &#8220;fencepost errors&#8221;, etc.</p>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>What does this do?</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

val list = List(Some(0), None, Some(1), None, Some(2), None, Some(3))
val list2 = for {
  option &lt;- list
  number &lt;- option
  if number % 2 == 0
} yield (number)
</pre></div>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>What does this do?</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

val list = List(Some(0), None, Some(1), None, Some(2), None, Some(3))
val list2 = for {
  option &lt;- list
  number &lt;- option
  if number % 2 == 0
} yield (number)

// list2: List[Int] = List(0, 2)
</pre></div>
<p>No checks for <code>None</code> required! Another argument for preferring <code>Options</code> instead of <code>nulls</code>, too.</p>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>In the Akka project, many methods return <code>Option[A]</code> so that when they have no results (and return <code>None</code>) they are simply ignored by for comprehensions.</p>
<p>(Note: There are times when you might want to report that no results were found, but that can usually be handled in the lower-level method.)</p>
<p>For comprehensions are very declarative. They abstract over the details of handling &#8220;no results&#8221;, iteration, etc.</p>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>In Scala, for comprehensions that <code>yield</code> are actually &#8220;sugar&#8221; around calls to <code>map</code> and <code>flatMap</code> (the <code>x &lt;- expression</code> expressions), and <code>filter</code> (the <code>if</code> expressions).</p>
<p>If the comprehension doesn&#8217;t <code>yield</code>, it is sugar around equivalent <code>filter</code> and <code>foreach</code> expressions.</p>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>For comprehensions can also have <em>definitions</em>, e.g., <code>string = number.toString</code>.</p>
<p>The <code>x &lt;- expression</code> expressions are called <em>generators</em>, because they generate a sequence. For example:</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

for (i &lt;- (0 to 5)) yield i
// =&gt; ...immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5)

// Sugar for a call to map? It's equivalent to: 
(0 to 5) map (i =&gt; i)
// =&gt; ...immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5)
</pre></div>
</div>
<div class="slide">
<h1>For Comprehensions</h1>
<p>Where does <code>flatMap</code> come in?? Consider this comprehension:</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

for {
  i &lt;- (1 to 4)
  j &lt;- (1 to i)  // like a nested for loop in Java
} yield j
// =&gt; ...immutable.IndexedSeq[Int] = Vector(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)

// Sugar for a call to map and flatMap? It's equivalent to: 
(1 to 4) map (i =&gt; i) flatMap (j =&gt; (1 to j))
// =&gt; ...immutable.IndexedSeq[Int] = Vector(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)
</pre></div>
<p>The second version only takes one line ;), but it&#8217;s harder to understand.</p>
</div>
<div class="slide">
<h1>Function(Data, Args) Vs. Receiver.Method(Args)</h1>
</div>
<div class="slide">
<h1>Pattern Matching and Collections</h1>
</div>
<div class="slide">
<h1><span class="caps">OCP</span> and Expression Problem</h1>
<p>Last week, we discussed the <em>Open-Closed Principle</em> (<span class="caps">OCP</span>), an object-oriented solution to a problem that Philip Wadler called the <em>Expression Problem</em>.</p>
</div>
<div class="slide">
<h1><span class="caps">OCP</span> and Expression Problem</h1>
<p>Specifically, how do we add new behavior without modifying existing code? This is useful so we minimize the need to retest and redeploy code that has already been tested and deployed, which can be costly in many cases.</p>
</div>
<div class="slide">
<h1><span class="caps">OCP</span> and Expression Problem</h1>
<p>In the object-oriented approach, we rely on a well-defined abstraction, which is implemented by concrete types to add new behaviors. As long as the abstraction is sufficiently expressive and clients don&#8217;t depend on the concrete subtypes, we can add new concrete subtypes to add new behaviors to the code base.</p>
</div>
<div class="slide">
<h1><span class="caps">OCP</span> and Expression Problem</h1>
<p>Example: geometric shapes</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

case class Point(x: Double, y: Double)
trait Shape { 
  def draw: Unit
}
case class Circle(center: Point, radius: Double) extends Shape { 
  def draw: Unit = // draw the shape
}
case class Rectangle(lowerLeft: Point, upperRight: Point) extends Shape { 
  def draw: Unit = // draw the shape
}
</pre></div>
<p>We can easily add new shapes (&#8220;behaviors&#8221;) in other files by extending <code>Shape</code>. Now, client code won&#8217;t break when we add (or remove) shapes, if the code only depends on <code>Shape</code>.</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val shapes = ...
shapes foreach { _.draw }
</pre></div>
</div>
<div class="slide">
<h1><span class="caps">OCP</span> and Expression Problem</h1>
<p>But wait, even these case classes are abstract in the sense that <code>draw</code> will be different depending on the graphics library, etc. In fact, you might not even need <code>draw</code> in many contexts (e.g., rendering an image, but not yet drawing it).</p>
<p>Also, what if we suddenly need the ability to <em>serialize</em> and <em>deserialize</em> shapes, e.g., for writing to and reading from files?</p>
<p>Do we now have find and modify all shape definitions in the code base to add this functionality, then retest, redeploy, etc.?</p>
</div>
<div class="slide">
<h1><span class="caps">OCP</span> and Expression Problem</h1>
<p>In &#8220;naïve&#8221; OO, we would say that the <em>draw</em>, <em>serialize</em>, and <em>deserialize</em> should be methods on the <code>Point</code> and <code>Shape</code> type hierarchies. At least as early as the nineties, people realized it&#8217;s not a good idea, and sometimes impossible, to add every such method to objects. So, they invented the <em>Visitor Design Pattern</em>, which is documented in the &#8220;Gang of Four&#8221; patterns book.</p>
<p>This is actually an <em>inelegant</em> pattern that disrupts the code significantly. It&#8217;s been widely criticized, even called an <em>antipattern</em>. We won&#8217;t discuss it further. Instead, let&#8217;s discuss a far more elegant solution: <em>type classes</em>.</p>
</div>
<div class="slide">
<h1>Type Classes</h1>
<p>So, how do we add new behaviors to types, <em>as if the types already supported these behaviors</em>? In OO terms, we would like the new behaviors to work like methods on the types.</p>
<p>Enter <em>type classes</em>, a term from Haskell, where the word <code>class</code> here should not be confused with the notion of <code>class</code> in typical OO languages (like Scala).</p>
</div>
<div class="slide">
<h1>Type Classes</h1>
<p>Both the visitor pattern and type classes support the following two goals:</p>
<ol>
	<li>Avoiding the difficulty of adding a &#8220;similar&#8221; behavior to a family of existing types.</li>
	<li>Avoiding <em>feature creep</em> in types, where behavior is now available <em>globally</em>, even when it&#8217;s only needed in a few <em>local contexts</em>.</li>
</ol>
<p>To explain #2, recall that <code>draw</code> might not be needed by all clients of the <code>Shapes</code>. Only those clients which draw shapes should pay that &#8220;tax&#8221;.</p>
</div>
<div class="slide">
<h1>Type Classes</h1>
<p>Conceptually, a type class is like an interface that defines some operations to support a behavior:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val shapes = ...
trait Drawable { 
  def draw: Unit
}
</pre></div>
<p>There is a &#8220;class&#8221; (or set) of types that can support this behavior, hence the name.</p>
</div>
<div class="slide">
<h1>Type Classes</h1>
<p>But wait, is this any different than the <em>mixins</em> we saw previously? Yes:</p>
<ul>
	<li>The implementation of <code>draw</code> varies with the type, unlike mixin behavior.</li>
	<li>To use a mixin, we have to control instantiation of the objects, which isn&#8217;t always possible.</li>
</ul>
<p>So, it&#8217;s not really the same as an interface (trait) in OO terms.</p>
<p>Type classes were invented for Haskell. Here&#8217;s how we can simulate them in Scala. We use <em>implicits</em>.</p>
</div>
<div class="slide">
<h1>Type Classes</h1>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

// An exception for when we FORGET to support a shape!
case class DrawNotUnsupported(a: Any) 
  extends RuntimeException(a.toString + " does not support draw")
  
class Drawable(shape: Shape) {
  def draw = shape match {
    case c: Circle =&gt; doDraw(c)
    case r: Rectangle =&gt; doDraw(r)
    case _ =&gt; throw DrawNotUnsupported(shape) 
  }
  private
  def doDraw(s: Shape) = println(s) // just print it for now.
}

object Drawable {
  // An implicit method, invoked by the compiler to convert shape:
  implicit def shapeToDrawable(s: Shape) = new Drawable(s)
}
...
</pre></div>
</div>
<div class="slide">
<h1>Type Classes</h1>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

...
case class Point(x: Double, y: Double)
// Remove the draw methods now!
trait Shape  
case class Circle(center: Point, radius: Double) extends Shape
case class Rectangle(lowerLeft: Point, upperRight: Point) extends Shape

import Drawable._  // bring the implicit method in scope

Circle(Point(0.0, 0.0), 5.0).draw  // call the draw "method"!
// =&gt; Circle(Point(0.0,0.0),5.0)

Rectangle(Point(0.0, 0.0), Point(4.0, 2.0)).draw
// =&gt; Rectangle(Point(0.0,0.0),Point(4.0,2.0))

// Add a new Triangle class:
case class Triangle(one: Point, two: Point, three: Point) extends Shape
Triangle(Point(0.0, 0.0), Point(2.0, 0.0), Point(1.0, 1.0)).draw
// =&gt; ...DrawNotUnsupported: Triangle(Point(0.0,0.0),...) does not support draw
// =&gt;   (stack trace)
</pre></div>
</div>
<div class="slide">
<h1>Type Classes</h1>
<p>+ Localizes behavior not universally applicable for types.<br />
+ Permits the addition of behavior without modifying existing types (<span class="caps">OCP</span>/Expression Problem).</p>
<p>- <em>Everything</em> about a particular type is not in one place.<br />
- Easy to forget to change the type class code when the type hierarchy changes.</p>
<p>(Some of these points are more specific to the Scala implementation).</p>
</div>
<div class="slide">
<h1>Combinators</h1>
</div>
<div class="slide">
<h1>Laziness</h1>
<p>If you remember (fondly?) your math courses, you were often asked to manipulate expressions symbolically, e.g., reduce them to simpler forms, compute integrals or derivatives, etc. Then, you might have been asked to evaluate the expression for a final numerical result.</p>
<p>Also, you worked with infinite data types, like the set of real numbers, without having to specify a finite limit, like you have to do in software.</p>
</div>
<div class="slide">
<h1>Laziness</h1>
<p>&#8230; or do you?</p>
<p>In functional programming, <em>lazy evaluation</em> allows you to represent data structures &#8230; and computations &#8230; without requiring immediate evaluate.</p>
<p>In Haskell, everything is lazy by default. Let&#8217;s see one way to write the Fibonacci sequence (0, 1, 1, 2, 3, 5, 8, 13, &#8230;) using this feature.</p>
<p>First, recall the simplest definition of the Fibonacci sequence is this (using pseudo code):</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: plain,;">

fibs[0] = 0
fibs[1] = 1
fibs[n] = fibs[n-1] + fibs[n-2]
</pre></div>
</div>
<div class="slide">
<h1>Laziness</h1>
<p>Here is one of many ways to implement the sequence in Haskell.</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: plain,;">

fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
</pre></div>
<p>This is an <em>infinite</em> recursion. <code>fibs</code> is the sequence and it is defined by two recursive calls to itself. The sequence starts with 0 and 1 (<code>:</code> is the &#8220;cons&#8221; operator, which is <code>::</code> in Scala). The expression <code>zipWith (+) fibs (tail fibs)</code> is easiest to understand schematically:</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: plain,;">

val fibs2 = [0, 1, 1, 2, 3, 5, ...] // infinite!
val tail  = [1, 1, 2, 3, 5, ...]
val zipped = fibs2 zip tail // =&gt; [[0, 1], [1, 1], [1, 2], [2, 3], ...]
val map = zipped map (array =&gt; array[0] + array[1])
// =&gt; [1, 2, 3, 5, ...] which is everything after the initial 0 and 1!!
</pre></div>
</div>
<div class="slide">
<h1>Laziness</h1>
<p>This only works if the sequences are not evaluated <em>strictly</em>; i.e., they are <em>lazy</em>.</p>
<p>Most Scala collections are <em>strict</em>, but <code>Streams</code> are lazy. So, here&#8217;s the same formula in Scala:</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

lazy val fib: Stream[Int] = 
  Stream.cons(0, Stream.cons(1, fib.zip(fib.tail).map(p =&gt; p._1 + p._2)))
fib.take(15).print
// =&gt; 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...
</pre></div>
<p>Courtesy <a href="http://www.scala-blogs.org/2007/12/project-euler-fun-in-scala.html">Jorge Ortiz</a>.</p>
</div>
<div class="slide">
<h1>Lazy Functions</h1>
<p>Of course, functions are also lazy in the sense that we define a computation, but treat it as a value that we can pass around and evaluate later.</p>
</div>
<div class="slide">
<h1>No Side Effects and Laziness: Drawbacks</h1>
<p>What&#8217;s wrong with this code?</p>
<div class="code-tiny">
<pre name="code" id="code" class="brush: scala,;">

println("Input your name, please.")
val response = readLine
</pre></div>
<ol>
	<li>They have side effects.<br />
We&#8217;re modifying the state of the world when we do I/O, which seems to violate the goal of side-effect-free functions.</li>
	<li>They can&#8217;t be evaluated <em>lazily</em>.<br />
A virtue of lazy evaluation is that the runtime can decide when or even if to evaluate an expression, but clearly we must have these two expressions evaluated in the order shown.</li>
</ol>
</div>
<div class="slide">
<h1>No Side Effects and Laziness: Drawbacks</h1>
<p>All functional languages must allow for these &#8220;exceptions&#8221;. Hybrid object-functional languages, like Scala, simply allow these exceptions anytime. &#8220;Pure&#8221; languages like Haskell use special containers, called <em>monads</em>, which let the programmer clearly indicate these statements must be strict and/or allow side effects.</p>
<p>Just as <em>software transactional memory</em> offers a &#8220;principled&#8221; way to manage state changes, techniques like monads are a &#8220;principled&#8221; way to allow essential side effects and strict evaluation in a controlled way.</div></p>

  <!-- Syntax Highlighter -->
  <script language="javascript" type="text/javascript" src="../lib/scripts/shCore.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushBash.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCpp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCSharp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCss.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushDelphi.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushJava.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushJScript.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPhp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPlain.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPython.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushRuby.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushScala.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushSql.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushVb.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushXml.js"></script>
  <script language="javascript">
    SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
    SyntaxHighlighter.all();
  </script>
</div>
</body>
</html>
