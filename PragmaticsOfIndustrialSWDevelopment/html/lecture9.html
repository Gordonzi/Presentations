<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Pragmatics of Industrial Software Development</title>
<!-- metadata -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<meta name="date" content="August 5, 2010" />
<meta name="author" content="Dean Wampler, Ph.D." />
<meta name="company" content="Department of Computer Science,<br/>Loyola University Chicago" />
<meta name="copyright" content="2010 Dean Wampler, All Rights Reserved" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="../ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="../ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="../lib/stylesheets/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="../ui/default/opera.css" type="text/css" media="projection" id="operaFix" />

<link rel="stylesheet" href="../lib/stylesheets/pressie.css" type="text/css" />

<!-- S5 JS -->
<script src="../ui/default/slides.js" type="text/javascript"></script>

<!-- Syntax Highlighter -->
<!-- <link rel="stylesheet"  href="../lib/stylesheets/SyntaxHighlighter.css"></link> -->
<link type="text/css" rel="stylesheet" href="../lib/stylesheets/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../lib/stylesheets/shThemeDefault.css"/>


</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h2>Copyright &copy; 2010 Dean Wampler, All Rights Reserved</h2>
<h2>August 5, 2010</h2>
</div>

</div>


<div class="presentation">
<div class="slide">
<h1>Lecture 9: Effective Object-Oriented Programming (<span class="caps">OOP</span>), Part II</h1>
</div>
<div class="slide">
<h1>Why Are Objects Interesting?</h1>
<p>Because managing complexity is one of our biggest challenges. Mentally, we object encapsulation in our daily lives to avoid being overwhelmed by sensory input. Object-Oriented Programming tries to apply that same strategy to managing software complexity.</p>
<p>However, like any tool, objects can be used in situations where their drawbacks outweigh their benefits.</p>
</div>
<div class="slide">
<h1>Some History</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 1967 </td>
		<td> Simula </td>
		<td> Objects, classes, subclasses, virtual methods, coroutines, discrete event simulation, garbage collection. </td>
		<td> First OO Language.</td>
	</tr>
	<tr>
		<td> 1972 </td>
		<td> Smalltalk </td>
		<td> Object-oriented, dynamically typed, reflective. </td>
		<td> First public version in 1980</td>
	</tr>
</table>
</div>
</div>
<div class="slide">
<h1>Some History (cont.)</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 1983 </td>
		<td> C++ </td>
		<td> Classes, virtual functions, operator overloading, multiple inheritance, templates. </td>
		<td> Most widely used OO language in the 90s. (?) </td>
	</tr>
	<tr>
		<td> 1986 </td>
		<td> Eiffel </td>
		<td> Design by contract, command-query separation, uniform-access principle, single-choice principle, open-closed principle, and option-operand separation </td>
		<td> Very innovative. Still used in some industries, esp. in Europe.</td>
	</tr>
</table>
<p>In 1984, Apple introduced the Macintosh, the first popular copmuter with a Graphical User Interface. GUIs were quickly seen as ideal for <span class="caps">OOP</span>.</p>
</div>
</div>
<div class="slide">
<h1>Some History (cont.)</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 1995 </td>
		<td> Java </td>
		<td> &#8220;Simplified C++&#8221;, plus byte code running on a virtual machine. </td>
		<td> Rapid adoption with the Internet. </td>
	</tr>
	<tr>
		<td> 1995 </td>
		<td> JavaScript </td>
		<td> Prototype-based, scripting, dynamically and weakly typed, first-class functions, closures, higher-order functions. </td>
		<td> Also considered a functional programming language. Inspired by Scheme. </td>
	</tr>
</table>
</div>
</div>
<div class="slide">
<h1>Some History (cont.)</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 2003 </td>
		<td> Scala </td>
		<td> Object-oriented and functional programming. </td>
		<td> Runs on the <span class="caps">JVM</span> and .<span class="caps">NET</span> <span class="caps">CLR</span>. </td>
	</tr>
	<tr>
		<td> 2007 </td>
		<td> Clojure </td>
		<td> Lisp on the <span class="caps">JVM</span>. </td>
		<td> Innovative approaches to mutable state. </td>
	</tr>
</table>
<p>The rise of functional programming, with some languages taking a hybrid object-functional approach, like Scala, OCaml, and JavaScript, while other languages are discounting the value of objects, like Clojure.</p>
</div>
</div>
<div class="slide">
<h1>Eiffel Innovations</h1>
<ul>
	<li><strong>Design by Contract:</strong> Discussed last lecture.</li>
	<li><strong>Command-Query Separation:</strong></li>
	<li><strong>Uniform-Access Principle:</strong></li>
	<li><strong>Single-Choice Principle:</strong> (a.k.a. <em>Don&#8217;t Repeat Yourself</em>)</li>
	<li><strong>Open-Closed Principle:</strong></li>
	<li><strong>Option-Operand Separation:</strong> (We won&#8217;t discuss this one.)</li>
</ul>
</div>
<div class="slide">
<h1>Command-Query Separation</h1>
<p>To keep each &#8220;piece&#8221; of code as simple as possible, each object and function should <em>do only one &#8220;thing&#8221;</em>. This is the <em>Single Responsibility Principle</em>, the &#8220;S&#8221; in the <span class="caps">SOLID</span> principles.</p>
</div>
<div class="slide">
<h1>Command-Query Separation (cont.)</h1>
<p>If a function executes a &#8220;command&#8221; and it returns a value (&#8220;query&#8221;), it&#8217;s doing <em>two</em> things. Hence, you should have separate command and query functions:</p>
<ul>
	<li><strong>Command:</strong> Do something, i.e., update state, but don&#8217;t return values. (It might return a &#8220;success&#8221; indicator&#8230;)</li>
	<li><strong>Query:</strong> Return a result, but don&#8217;t alter state (at least not the visible state &#8211; it may update an internal <em>cache</em>, for example.)</li>
</ul>
<p>Example: JavaBean getters and setters.</p>
</div>
<div class="slide">
<h1>CQ Separation: Counterexamples</h1>
<p><strong>Builders:</strong></p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

import org.chicagoscala.awse.domain.finance._
val criteria = CriteriaMap().
  withInstruments(instruments).
  withStatistics(statistics).
  withStart(start).
  withEnd(end)
</pre></div>
<p><strong>Functional Operations:</strong></p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

// Generate a sequence of strings: "2", "4"
(1 to 10) filter (_ % 2 == 0) map (_.toString) take 2
// ...immutable.IndexedSeq[java.lang.String] = Vector(2, 4)
</pre></div>
</div>
<div class="slide">
<h1>Uniform-Access Principle</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

case class Person(name:String, age: Int)
...
val dean = Person("Dean Wampler")
println(dean.name)
</pre></div>
<p>Am I calling a method <code>name</code> or accessing a &#8220;bare&#8221; <code>name</code> field??</p>
</div>
<div class="slide">
<h1>Uniform-Access Principle (cont.)</h1>
<p>The <em>caller</em> doesn&#8217;t care whether a method is invoked or a bare field is accessed.<br />
 <br />
The <em>implementer</em> might want to start with a simple bare field access, then eventually replace it with a method call (e.g., to do lazy initialization, etc.).</p>
<p>The <em>uniform-access principle</em> means the caller&#8217;s code doesn&#8217;t have to change, because the syntax is identical. (The code might need a recompile).</p>
</div>
<div class="slide">
<h1>Uniform-Access Principle (cont.)</h1>
<p>Note that the JavaBean convention for getters and setters does <em>not</em> support this principle!</p>
<div class="code-small">
<pre name="code" id="code" class="brush: java,;">

class Person {
  private String name;
  public String getName() { return name; }
  
  public Person(String name) { this.name = name; }
}
...
val dean = Person("Dean Wampler")
println(dean.getName());
// very different from:
// println(dean.name);
</pre></div>
</div>
<div class="slide">
<h1>Single-Choice Principle</h1>
<p>This is now more commonly known as <span class="caps">DRY</span>, <em>Don&#8217;t Repeat Yourself</em>. It means, don&#8217;t write code that duplicates the work of other code.</p>
<ul>
	<li>Leads to bloat.</li>
	<li>Each version must be maintained, kept in sync.
	<ul>
		<li>It&#8217;s very common for the versions to &#8220;grow&#8221; out of sync, leading to bugs.</li>
	</ul></li>
</ul>
</div>
<div class="slide">
<h1>Good Object Design: Lesson 4</h1>
<p><em>Don&#8217;t Repeat Yourself</em> is more valuable than it might sound at first. Removing duplication pays dividends in terms of code quality, size, and maintainability over the life of a project.</p>
</div>
<div class="slide">
<h1>Open-Closed Principle</h1>
<p>The &#8220;O&#8221; in the <span class="caps">SOLID</span> principles.</p>
<p>How can we add new behavior to the system without editing existing code? Philip Wadler called this the <em>Expression Problem</em>.</p>
<p>If we edit existing code,</p>
<ul>
	<li>we must retest, redeploy&#8230;</li>
	<li>we force clients of the code to modify their code and retest, redeploy&#8230;</li>
</ul>
</div>
<div class="slide">
<h1>Open-Closed Principle (cont.)</h1>
<p>Inheritance is a classic way to do this. Our windowing example demonstrates this:</p>
<center>
<span style="width: 100%;">
<img src="images/Windows_WindowsFactories.png"></img>
</span>
</center>
<p>We could add iPhone and Android classes, for example, without changing any existing classes&#8230; in principle&#8230;</p>
</div>
<div class="slide">
<h1>Open-Closed Principle (cont.)</h1>
<p>In practice, when you introduce new subclasses, the existing abstractions may not fully support their needs, forcing some changes on the existing types. Hopefully, that&#8217;s rare.</p>
</div>
<div class="slide">
<h1>Open-Closed Principle (cont.)</h1>
<p>We&#8217;ll return to this principle when we talk about <em>Type Classes</em> in functional programming.</p>
</div>
<div class="slide">
<h1>Good Object Design: Lesson 5</h1>
<p>In long-lived projects, take the time to factor out abstractions so you can exploit the <em>Open-Closed Principle</em>. It will minimize the maintenance effort over time.</p>
</div>
<div class="slide">
<h1>Strong Dependencies</h1>
<p>Last time, we talked at length about encapsulation. We also mentioned that it helps minimize dependencies (coupling) between modules. Some of the principles we just discussed also do this. Let&#8217;s explore dependencies some more.</p>
<center>
<p><img src="images/Module_Dependencies.png"></img></p>
</center>
<p>Is it bad if <code>GUI</code> depends on <code>MacWindowFactory</code>??</p>
</div>
<div class="slide">
<h1><code>gui.windowing</code></h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package gui.windowing {

  abstract class Window(dimensions: Dimensions) {...}  
  abstract class WindowFactory {
    def make(properties: Properties): Window
  }
  
  protected[gui] package mac {
    MacWindow(...) extends Window(...) {...}
    object MacWindowFactory extends WindowFactory {
      def make(properties: Properties): Window = {...}
    }
  }
  protected[gui] package windows {
    WindowsWindow(...) extends Window(...) {...}
    ...
  }
  ...
}
</pre></div>
</div>
<div class="slide">
<h1>Other Modules</h1>
<p><span class="caps">BAD</span>:<br />
<div class="code-small"></p>
<pre name="code" id="code" class="brush: scala,;">

object MyApp {
  def makeNewWindow(properties: Properties) {
    val window = mac.MacWindowFactory.make(properties)
    // Other Mac-specific calls...
  }
}
</pre></div>
<p><span class="caps">GOOD</span>:<br />
<div class="code-small"></p>
<pre name="code" id="code" class="brush: scala,;">

object MyApp {
  def makeNewWindow(properties: Properties) {
    val window = WindowFactory.make(properties)
    // Other generic calls...
  }
}
</pre></div>
</div>
<div class="slide">
<h1>Why Are Strong Dependencies Bad?</h1>
<ul>
	<li><strong>Testing</strong></li>
	<li><strong>Maintenance</strong></li>
</ul>
</div>
<div class="slide">
<h1>Testing</h1>
<p>If I want to test a module, I have to set up all its dependencies. That&#8217;s painful if the dependencies are <strong>concrete</strong> objects like database connections, user interfaces, external processes, etc.</p>
<p>For example, I could only test the &#8220;bad&#8221; version of <code>MyApp.makeNewWindow</code> with a Macintosh. Also, in general, creating <span class="caps">GUI</span> widgets is much slower than avoiding real UI calls.</p>
<p>But if <code>makeNewWindow</code> depends only on abstractions (e.g., Java interfaces), I can use a <em>stub</em> implementation of <code>WindowFactory</code> that makes <em>unit</em> testing easy and fast.</p>
<p>(We&#8217;ll revisit testing in a few weeks.)</p>
</div>
<div class="slide">
<h1>Maintenance</h1>
<p>If you have several other teams that depend on the implementation of <code>MacWindowFactory</code>, you can&#8217;t change it without pain:</p>
<ul>
	<li>You have to plan with those teams when to introduce the changes.</li>
	<li>You and they have to coordinate the changes.</li>
	<li>They have to <em>unit</em> test their changes in isolation.</li>
	<li>The organization has to <em>integration</em> test the changes.</li>
	<li>All the changes need to be deployed in a coordinated manner.</li>
</ul>
</div>
<div class="slide">
<h1>Good Object Design: Lesson 6</h1>
<p>Keep dependencies to a minimum.</p>
<ul>
	<li>Depend only on abstractions.</li>
	<li>Depend on a minimum number of modules.</li>
</ul>
</div>
<div class="slide">
<h1>Inheritance Is A Strong Dependency</h1>
<p>It&#8217;s important to note that <em>inheritance is a form of strong dependency</em>. (About the strongest in fact.) The advantages vs. disadvantages need to be weighed.</p>
</div>
<div class="slide">
<h1>Inheritance Is A Strong Dependency (cont.)</h1>
<p><strong>Advantages:</strong></p>
<ul>
	<li>Reuse of state and behavior.</li>
	<li>Grouping of &#8220;logically-similar&#8221; things.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
	<li>Any change to parent may require changes to child.</li>
	<li>Proper implementations of <code>clone</code>, <code>equals</code>, <code>hashCode</code> challenging.</li>
	<li>Can&#8217;t &#8220;abstract over&#8221; the dependency.</li>
</ul>
<p>Like any form of dependency, it should be used <em>sparingly</em>.</p>
</div>
<div class="slide">
<h1>Composition vs. Inheritance</h1>
<p>Compare the following approaches:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

abstract class Addressable(
  ..., val city:String, val state:String, val zip:ZipCode)
  
case class Person(name:String, age: Int)
  extends Addressable
</pre></div>
<p>Does <code>Person</code> <em>behave as</em> an <code>Addressable</code>? What does <em>that</em> mean?</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

class Address(
  ..., val city:String, val state:String, val zip:ZipCode)
  
case class Person(name:String, age: Int, address: Address)
</pre></div>
<p>Makes more sense to say <code>Person</code> <em>has an</em> <code>Address</code>.</p>
</div>
<div class="slide">
<h1>Composition vs. Inheritance (cont.)</h1>
<p>Not only does &#8220;<code>Person</code> <em>has an</em> <code>Address</code>&#8221; make more sense, but now we can treat address as an abstraction. For example, we can pass in the correct kind of address appropriate for the country the person lives.</p>
</div>
<div class="slide">
<h1>Less Trivial Example:</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package graphics {
  // Abstraction
  trait Rectangle {...}
}
package opengl {
  // Concrete implementation.
  class OGLRectangle(val lowerLeft: Point, val upperRight: Point) 
    extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // Inherits concrete implementation
  class X11Window(properties: Properties) 
    extends opengl.OGLRectangle(...) {...}
}
</pre></div>
</div>
<div class="slide">
<h1>Versus:</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package graphics {
  // Abstraction
  trait Rectangle {...}  
}
package opengl {
  // Concrete implementation.
  class OGLRectangle(val lowerLeft: Point, val upperRight: Point) 
    extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // Uses an object implementing abstraction.
  class X11Window(properties: Properties, rect: Rectangle) {...} 
}
</pre></div>
<p>We <em>compose</em> the X11 window with an implementing rectangle.</p>
</div>
<div class="slide">
<h1>Composition vs. Inheritance (cont.)</h1>
<p>So, dependency on abstractions is the weakest form of dependency. Therefore, we should prefer <em>composing</em> behavior over <em>inheriting</em> it.</p>
<p><strong>Object Properties:</strong></p>
<p>Every property is a reference to another object (as long as you consider, numbers, booleans, etc. objects&#8230;)</p>
</div>
<div class="slide">
<h1>Mixins</h1>
<p>An alternative to using <em>properties</em> is to use <em>mixins</em>, which are like standalone objects (they have their own <em>behavior</em>: state and/or functions), but they are designed to be mixed into other objects using the inheritance mechanism, but with weaker coupling.</p>
<p>Most of the time, these behaviors will be <em>orthogonal</em>.</p>
<center>
<span style="width: 100%;">
<img src="images/StateSpace.png"></img>
</span>
</center>
</div>
<div class="slide">
<h1>Example: Logging Mixin</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package utils {
  trait Logging {
    def error(message: String) = {...}
    def warning(message: String) = {...}
    def info(message: String) = {...}
  }
}

package gui.windowing.x11 {  
  // Make all windows with logging mixed in:
  object X11WindowFactory extends WindowFactory { 
    def make(properties: Properties) = {
      val dimensions = // get dimensions from properties
      new X11Window(dimensions) with utils.Logging
    } // returns window WITH Logging mixed in!
  } 
}
</pre></div>
</div>
<div class="slide">
<h1>Mixins (cont.)</h1>
<p>Other times, the mixin behavior may be closely linked to the class.</p>
<p>Example: How could you model the M:N relationship between windowing toolkits (e.g., Xll, Windows, Aqua, etc.) and the low-level graphics APIs (e.g., OpenGL, DirectX, Quartz, etc.)</p>
</div>
<div class="slide">
<h1>Joining <span class="caps">GUI</span> and Graphics Libs</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package graphics { // for any graphics library...
  trait Rectangle {  // abstraction of rectangle.
    val lowerLeft: Point  // traits don't have constructors,
    val upperRight: Point // ... so we declare "fields" here.
    ...
  }
}
package opengl {  // OpenGL-specific "driver"
  trait OGLRectangle extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // "self type" declaration:
  // X11Window will be composed with a Rectangle...
  abstract class X11Window(properties: Properties) { 
    self: Rectangle =&gt;
    ...
  } 
}
</pre></div>
</div>
<div class="slide">
<h1>Self Types in Scala</h1>
<p><em>Self type declarations</em>, like this:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

abstract class X11Window(properties: Properties) { 
  self: Rectangle =&gt;
  ...
}
</pre></div>
<p>are &#8220;promises&#8221; that any <em>concrete</em> class eventually created from <code>X11Window</code> will mix in a <code>Rectangle</code> trait. In byte code, it is identical to <code>X11Window extends Rectangle</code>, but avoids the <em>is a</em> trap (Liskov Substitution Principle).</p>
</div>
<div class="slide">
<h1>Self Types in Scala</h1>
<p>In other words, we could write it this way:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

abstract class X11Window(properties: Properties) 
  extends Rectangle { 
  ...
}
</pre></div>
<p>However, that would imply that <code>X11Window</code> is <em>substitutable</em> for <code>Rectangle</code> (Liskov), which is a poor inheritance relationship.</p>
<p>Self types emphasize instead that we will get the &#8220;Rectangle&#8221; behavior we need through a mixin.</p>
</div>
<div class="slide">
<h1>Instantiating the Objects</h1>
<p>So, to create actual objects the factory method would do this:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

object X11WindowFactory extends WindowFactory { 
 def make(properties: Properties) = {
  val dimensions = // get dimensions from properties
  new X11Window(dimensions) with utils.Logging with OGLRectangle
  {
   val lowerLeft  = // get it from the dimensions
   val upperRight = // get it from the dimensions
  }
 } // returns window WITH Logging WITH OGLRectangle!
} 
</pre></div>
<p>Note: this technique is called the <a href="http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di.html">Cake Pattern</a> (also discussed <a href="http://programming-scala.labs.oreilly.com/ch13.html">here</a> and used to <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5834&amp;rep=rep1&amp;type=pdf">implement the Scala compiler itself</a>).</p>
</div>
<div class="slide">
<h1>Counterexample: Exception Hierarchies</h1>
<p>The Java exception hierarchy (and similar hierarchies in many other languages) is a good use of a deep inheritance hierarchy.</p>
<center>
<p><img src="images/exceptFig1.gif"></img></p>
</center>
<p>(credit: <a href="http://www.artima.com/designtechniques/exceptions.html">http://www.artima.com/designtechniques/exceptions.html</a>)</p>
</div>
<div class="slide">
<h1>Counterexample: Exception Hierarchies</h1>
<p>Why? Because this hierarchy forms a <em>classification tree</em>, similar to the way that all life on Earth is classified into the <em>Phylogenetic Tree</em>.</p>
<center>
<p><img src="images/450px-Phylogenetic_tree.png"></img></p>
</center>
<p>(credit: <a href="http://en.wikipedia.org/wiki/Phylogenetic_tree">http://en.wikipedia.org/wiki/Phylogenetic_tree</a>)</p>
</div>
<div class="slide">
<h1>Counterexample: Exception Hierarchies</h1>
<p>However, this only works if this hierarchy is very stable.</p>
</div>
<div class="slide">
<h1>Good Object Design: Lesson 7</h1>
<p>Prefer <em>composition</em> over <em>inheritance</em>.</p>
</div>
<div class="slide">
<h1>Problems with Objects</h1>
<p>Objects offer benefits, but they also pose theoretical and practical problems.</p>
<ul>
	<li><strong>Cloning Objects</strong></li>
	<li><strong>Determining Equality</strong></li>
	<li><strong>Typing of Object-Oriented Code</strong></li>
	<li><strong>Unrestrained Mutability</strong></li>
	<li><strong>Reusability</strong></li>
</ul>
</div>
<div class="slide">
<h1>Cloning Objects: Two Strategies</h1>
<ul>
	<li><strong>Shallow Copy:</strong> Parts are <em>shared</em>. References to other &#8220;sub-objects&#8221; in the new copy point to the same sub-objects in the original object.<br />
+ Faster cloning.<br />
- Changes to sub-objects affect both objects, so state is harder to control.</li>
	<li><strong>Deep Copy:</strong> Sub-objects are also copied, so the new and old objects are completely independent.<br />
- Expensive cloning.<br />
+ Easier to control state of each object separately.</li>
</ul>
<p>This is a language (or <span class="caps">API</span>) design decision. Needs to be consistently applied!</p>
</div>
<div class="slide">
<h1>Cloning Objects (cont.)</h1>
<p>Note that the &#8220;state problem&#8221; goes away if the objects are <em>immutable</em>!</p>
<p>This fact is exploited by <em>software transactional memory</em> implementations (e.g., subtree sharing) that we discussed earlier in the course.</p>
<p>Recall that modifications are implemented by creating new objects where the &#8220;invariant&#8221; parts are shared. No object is ever modified directly.</p>
</div>
<div class="slide">
<h1>Determining Equality</h1>
<p>It&#8217;s actually hard to <a href="http://www.artima.com/lejava/articles/equality.html">write a correct equality operator</a>. Let&#8217;s talk about Java, as a representative example.</p>
</div>
<div class="slide">
<h1>The Signature of <code>equals</code></h1>
<p>A common mistake is to get the signature wrong. Suppose I define <code>equals</code> for the <code>MacWindow</code> class we discussed earlier:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

boolean equals(MacWindow window) {...}  // WRONG!!
</pre></div>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

boolean equals(Object other) {...}  // Right!
</pre></div>
<p>Why? Because in Java collections, all objects are <code>Object</code>, so the run time won&#8217;t look for the method that takes an <code>MacWindow</code> argument. Rather, it will use the &#8220;closest&#8221; <code>equals</code> method that takes an <code>Object</code> argument, perhaps the one on <code>Object</code> itself.</p>
</div>
<div class="slide">
<h1>Overlooking <code>hashCode</code></h1>
<p>You have to keep <code>hashCode</code> consistent with <code>equals</code>:</p>
<p><em>If <code>equals</code> says that two objects are equivalent, then <code>hashCode</code> applied to each object should return the same value.</em></p>
<p>The default <code>Object.hashCode</code> simply uses the object&#8217;s reference address. So, if you put an  object in a <code>HashSet</code> for example, then test for its presence using an equal but different object, you <em>might</em> (or not) get a false negative, depending on whether or not the <em>addresses</em> of the two objects both get hashed into the same bucket!</p>
</div>
<div class="slide">
<h1>Mutability: <code>equals</code>, <code>hashCode</code></h1>
<p>This is related to the previous problem with <code>HashSet</code> and similar collections. Suppose you create an object, put it in a <code>HashSet</code>, then mutate the object. You <em>might</em> find that the <code>HashSet</code> no longer believes it has the object!</p>
<p>This is because the <code>HashSet</code> uses the value of <code>hashCode</code> to determine the correct bucket for the object. However, if the object is mutable, then the value returned by <code>hashCode</code> changes, so <code>HashSet</code> might start looking in the wrong bucket for the object!</p>
</div>
<div class="slide">
<h1><code>equals</code> Is an <em>Equivalence Relation</em></h1>
<p>Your <code>equals</code> must satisfy the following properties:</p>
<ul>
	<li><strong>Reflexive:</strong> for any non-null value <code>x</code>, the expression <code>x.equals(x)</code> should return true.</li>
	<li><strong>Symmetric:</strong> for any non-null values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return true <em>if and only if</em> <code>y.equals(x)</code> returns true.</li>
	<li><strong>Transitive:</strong> for any non-null values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns true and <code>y.equals(z)</code> returns true, then <code>x.equals(z)</code> should return true.</li>
</ul>
</div>
<div class="slide">
<h1><code>equals</code> Is an <em>Equivalence Relation</em> (cont.)</h1>
<ul>
	<li><strong>Consistent:</strong> for any non-null values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> should consistently return true or false, provided no information used in equals comparisons on the objects is modified.</li>
	<li><strong>Nulls:</strong> For any non-null value <code>x</code>, <code>x.equals(null)</code> should return false.</li>
</ul>
</div>
<div class="slide">
<h1><code>equals</code> Is an <em>Equivalence Relation</em></h1>
<p>That doesn&#8217;t sound hard, but a classic mistake is to allow objects to be considered equal if the values of their <em>common supertypes are equal</em>.</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

// Scala syntax now...
class Point2D(val x: Double, val y: Double) { 
  override def equals(other: Any): Boolean = other match {
      case p: Point2D =&gt; x == p.x &amp;&amp; y == p.y
      case _ =&gt; false
    }
  }}
  
class Point3D(x: Double, y: Double, val z: Double)
    extends Point2D(x, y) { 
  override def equals(other: Any): Boolean = other match {
      case p: Point3D =&gt; x == p.x &amp;&amp; y == p.y &amp;&amp; z == p.z
      case _ =&gt; false
    }
  }}
</pre></div>
</div>
<div class="slide">
<h1><code>equals</code> Is an <em>Equivalence Relation</em></h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val p2 = new Point2D(1, 2)
val p3 = new Point3D(1, 2, 3)
p2 == p3   // true
p3 == p2   // false!
</pre></div>
<p>Not only is symmetry broken, but this can lead to strange affects in collections, again.</p>
<p>(It also begs the question, is Liskov Substitutability satisfied by <br />
<code>Point2D &lt;: Point3D</code>?)</p>
</div>
<div class="slide">
<h1><code>equals</code> Is an <em>Equivalence Relation</em></h1>
<p>You could implement a fix for the symmetry by making the relation <code>a == b || b == a</code>, but this breaks transitivity:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val p2 = new Point2D(1, 2)
val p33 = new Point3D(1, 2, 3)
val p34 = new Point3D(1, 2, 4)
p2 == p33   // true
p33 == p2   // true, if we "fix" symmetry (see exercises)

p33 == p2   // true
p2  == p34  // true
p33 == p34  // false!
</pre></div>
</div>
<div class="slide">
<h1>Equals</h1>
<p>So, in most cases, you must also require the objects to be of the <em>same</em> type. However, than can be cases where a subtype doesn&#8217;t add any more <em>state</em> to the parent type. (We&#8217;ll see an example later in the lecture.) Objects of these types <em>could</em> be compared.</p>
<p>However, it&#8217;s still a questionable idea. Perhaps there shouldn&#8217;t be two different types after all?</p>
<p>See <a href="http://www.artima.com/lejava/articles/equality.html">here</a> for more details on show to implement this case.</p>
</div>
<div class="slide">
<h1>Typing of Object-Oriented Languages</h1>
<p>Creating a sophisticated and &#8220;sound&#8221; type system in object-oriented languages is harder than in a comparable functional language, because of subtyping. Java didn&#8217;t really try very hard. Scala goes quite far, but it takes some effort to master the type system (which is <em>Turing complete</em>, by the way).</p>
<p>Compare Haskell to Scala. Haskell infers most type information, while Scala is limited to <em>local type inference</em>, which is why the types of function arguments must be declared.</p>
</div>
<div class="slide">
<h1>Type &#8220;Invariance&#8221; Under Transformations</h1>
<p>Another common problem related to subtyping is what I&#8217;ll call the desire for <em>type invariance under transformations</em>. Here&#8217;s an example to describe what this means.</p>
<p>Suppose you want to map over a Scala <code>List</code>. Conveniently, <code>List</code> inherits a <code>map</code> method implementation that is defined in one of its ancestor types, <code>TraversableLike</code>.</p>
<p>Here&#8217;s the problem, I would like the result to also have the type <code>List</code>, not <code>TraversableLike</code> or some other lowest-common denominator type. However, I definitely don&#8217;t want <code>TraversableLike</code> to know about <code>List</code> or another other subtype.</p>
</div>
<div class="slide">
<h1>Type &#8220;Invariance&#8221; Under Transformations</h1>
<p>In a lot of strongly-typed object-oriented languages, there is no built-in way to get a new collection with the same type as the original (with the type parameter for the <code>List</code> possibly changed). Scala pre-2.8 also didn&#8217;t do this. However, Scala 2.8 exploits <em>implicit parameters</em> and special factory objects to do this.</p>
</div>
<div class="slide">
<h1>Type &#8220;Invariance&#8221; Under Transformations</h1>
<p>We want something &#8220;equivalent&#8221; to this <code>map</code> method signature for <code>List</code>:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

class List[A] {
  def map [B] (f: (A) ⇒ B): List[B]
  ...
}
</pre></div>
<p>Here is the actual signature for <code>TraversableLike.map</code></p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

trait TraversableLike {
  def map [B, That] (f: (A) ⇒ B)(
      implicit bf: CanBuildFrom[Repr, B, That]) : That
  ...
}
</pre></div>
</div>
<div class="slide">
<h1>Type &#8220;Invariance&#8221; Under Transformations</h1>
<p>Note there are two argument <em>lists</em> and the second one takes a single <code>implicit</code> parameter. Recall that the user doesn&#8217;t have to specify these parameters if a suitable object is in scope. Here, <code>CanBuildFrom</code> is supplied by the Scala library. It knows how to build a <code>List[B]</code> object (which is what <code>That</code> represents), based on the current &#8220;representation&#8221; <code>Repr</code> and the type parameter <code>B</code>.</p>
</div>
<div class="slide">
<h1>Static Types vs. Real-World Variability</h1>
<p>It is sometimes said that &#8220;objects model the real world&#8221;. One problem with this view is that real world objects are not always fixed and unchangeable. They can be more fluid, depending on context and changes over time.</p>
<p>However, class-based and especially statically-typed languages don&#8217;t reflect this fluid nature of reality. Prototype languages and languages with &#8220;open types&#8221; are more accommodating to this kind of change.</p>
<p>Yet, as we&#8217;ll discuss in subsequent lectures, trying to mimic the world too faithfully is overkill for most programming problems.</p>
</div>
<div class="slide">
<h1>Unrestrained Mutability</h1>
<p>It&#8217;s a hallmark of <span class="caps">OOP</span> that you send messages to objects, which do appropriate computations, possibly modifying internal state, then send a reply to the caller and/or send other messages to other objects.</p>
<p>However, the mutability part presents problems.</p>
</div>
<div class="slide">
<h1>Mutability and Correctness</h1>
<p>We saw earlier that <code>hashCode</code> and <code>equals</code> are unreliable when objects mutate.</p>
<p>Mutability also makes evaluating <em>correctness</em> (e.g., through testing) more difficult, because if we are testing one thing, we have to also test how it affects mutable objects with which it interacts.</p>
<p>Furthermore, as we discussed last week, you have to carefully consider the state transitions of an object.</p>
</div>
<div class="slide">
<h1>Mutability and Concurrency</h1>
<p>However, more than any other reason, the growing need to embrace <em>concurrency</em> to create scalable and reliable applications has made mutability more problematic.</p>
<p>As we discussed in an earlier lecture, all the locking challenges of multi-threaded programming go away when objects are immutable.</p>
</div>
<div class="slide">
<h1>Reusability</h1>
<p>As <span class="caps">OOP</span> went mainstream, a perceived benefit was the ability to create <em>reusable object libraries</em>. This largely failed, except in limited cases (such as collections libraries and windowing APIs).</p>
<p>Why?</p>
</div>
<div class="slide">
<h1>Reusability and &#8220;Baroque&#8221; Abstractions</h1>
<p>We&#8217;ll explore this topic in depth towards the end of the course, but for now, note that objects can expose abstractions with almost no constraints at all. They can take virtually any form, following many different conventions and styles. Paradoxically, this freedom <em>inhibits</em> reuse, because one object library is rarely <span class="caps">API</span>-compatible with others.</p>
<p>Also, library designers often do a poor job of <em>minimizing dependencies</em> (coupling), so to use their library requires you to use lots of dependencies you might not want.</p>
<p>(We felt this pain, unfortunately, when setting up the Akka project.)</p>
</div>
<div class="slide">
<h1>Conclusions, Part II</h1>
<p>Effective OO design exploits principles like the <em>Open-Closed Principle</em> and the <em>Liskov-Substitution Principle</em> to minimize coupling and the impact of changes on clients of the code, etc.</p>
<p>In addition to their benefits, objects present a number of difficulties. Correct implementations of <code>equals</code> and <code>hashCode</code> are hard to write. Mutability causes a number of problems.</p>
</div>
<div class="slide">
<h1>Reading Assignments: <span class="caps">OOP</span></h1>
<ul>
	<li><a href="http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di.html" title="DI">Real-World Scala: Dependency Injection</a>.</li>
	<li><a href="http://www.artima.com/lejava/articles/equality.html">How to Write an Equality Method in Java</a>.</li>
</ul>
</div>
<div class="slide">
<h1>Reading Assignments: FP</h1>
<ul>
	<li><a href="http://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> (Wikipedia).</li>
	<li><a href="http://www.defmacro.org/ramblings/fp.html">Functional Programming for the Rest of Us</a>.</li>
</ul>
</div>
<div class="slide">
<h1>Exercise 1: Equality</h1>
<p>Implement the &#8220;improved&#8221; equals methods for <code>Point2D</code> and <code>Point3D</code> that satisfy symmetry. Demonstrate by example that they satisfy symmetry, but still fail to satisfy transitivity.</p>
</div>
<div class="slide">
<h1>Exercise 2: Design by Contract</h1>
<p>In the Akka project, consider <code>DataStore.range</code> in the <code>org.chicagoscala.awse.persistence</code> package.</p>
<p>Write down all the preconditions, postconditions, and invariants that you can think of that would be reasonable constraints on this method. (Hint: the <code>DataStoreTest</code> checks some, but not all of the possibilities.)</p>
</div>
<div class="slide">
<h1>Exercise 3: Select a &#8220;Mini-Project&#8221; by Next Tuesday</h1>
<p>Talk to me over the next week about what you want to do for the mini-project we discussed last week. We need to agree on a project by next Tuesday, November 9.</p>
</div>
<div class="slide">
<h1>Appendix: <span class="caps">LSP</span> Revisited</h1>
<p>Let&#8217;s return to the Liskov Substitution Principle (<span class="caps">LSP</span>) and discuss how it works under inheritance.</p>
<p>Recall this definition from the last lecture:</p>
</div>
<div class="slide">
<h1>Liskov Substitution Principle (<span class="caps">LSP</span>)</h1>
<p><em>Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T.</em></p>
<p><span style="text-align: right; width: 100%"><br />
(The <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>)<br />
</span></p>
<p>It&#8217;s a definition of <em>subtyping</em>; If I claim that <code>S</code> is a subtype of <code>T</code>, then objects of type <code>S</code> must obey the <em>contract</em> defined for objects of type <code>T</code>.</p>
<p>I said <em>contract</em>, didn&#8217;t I? There&#8217;s a close relationship between <span class="caps">LSP</span> and Design by Contract.</p>
</div>
<div class="slide">
<h1>How Subclasses Must Behave</h1>
<p>First, let&#8217;s define <code>Output</code> and <code>LineOrientedOutput</code> classes:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

class Output(val name: String) {
  def write(chars: Array[Character]) = {...}
  override def toString = "Output(" + name + ")"
}
class LineOrientedOutput(name: String) 
    extends Output(name) {
  def writeln(string: String) = {...}
  override def toString = "LineOrientedOutput(" + name + ")"
}
</pre></div>
<p><code>LineOrientedOutput</code> <em>specializes</em> <code>Output</code> to add support for writing a line at a time.</p>
</div>
<div class="slide">
<h1>How Subclass Must Behave (cont.)</h1>
<p>Now, consider <em>function literals</em> (a.k.a <em>anonymous functions</em>) in Scala, which we&#8217;ll use in a call to <code>List.map</code>:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

// Return a list of Output streams.
def toOutputs(list: List[String]): List[Output] =
  list map { s =&gt; new Output("out" + s) }

val outputs: List[Output] = toOutputs(List("A", "B"))
// =&gt; List(Output(outA), Output(outB))
</pre></div>
</div>
<div class="slide">
<h1>How Subclass Must Behave (cont.)</h1>
<p>For the anonymous function, the scala compiler generates an <em>anonymous subclass</em> of the <code>Function1[String,Output]</code> <em>trait</em>:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

new Function1[String,Output] {
  def apply(s: String) = new Output("out" + s)
}
</pre></div>
<p>Note that the <em>body</em> of the function literal is used to define the <code>apply</code> method, which is abstract in the <code>Function1[A,B]</code> trait.</p>
</div>
<div class="slide">
<h1>How Subclass Must Behave (cont.)</h1>
<p>Let&#8217;s extract the anonymous function into a <code>val</code> and pass it to <code>toOutputs</code>:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val s2o: (String =&gt; Output) = s =&gt; new Output("out" + s)

def toOutputs(
     list: List[String], f: String=&gt;Output): List[Output] =
  list map f

val outputs: List[Output] = toOutputs(List("A", "B"), s2o)
// =&gt; List(Output(outA), Output(outB))
</pre></div>
<p>Is there a <em>subclass</em> of <code>String =&gt; Output</code>? If so, how should it behave?</p>
</div>
<div class="slide">
<h1>Function1 Subtypes</h1>
<p>Recall that the type is actually <code>Function1[-A,+R]</code>, where <code>A</code> is the type of the single argument and <code>R</code> is the type of the return value. Recall also from the last lecture that the <code>+R</code> means the return type behaves <em>covariantly</em> under inheritance, while <code>-A</code> means that the argument behaves <em>contravariantly</em> under inheritance. Let&#8217;s understand what this really means.</p>
</div>
<div class="slide">
<h1>Covariant and Contravariant Behaviors</h1>
<p>If I have a parameterized type <code>X[+A]</code>, it means that <code>X[String]</code> is a <em>subtype</em> of <code>X[AnyRef]</code>, since <code>String</code> is a <em>subtype</em> of <code>AnyRef</code>. This is <em>covariant</em> behavior.</p>
<p>However, if I have a parameterized type <code>Y[-A]</code>, it means that <code>Y[String]</code> is a <em>super type</em> of <code>Y[AnyRef]</code>, since <code>String</code> is a <em>subtype</em> of <code>AnyRef</code>. This is <em>contravariant</em> behavior.</p>
<p>The contravariant behavior is harder to grasp. Keep in mind that we are <em>always</em> discussing inheritance in the context of the <em>Liskov Substitution Principle</em>. Inheritance only has meaning in the sense that I can <em>substitute</em> an object of one type for an object of another type (i.e. a &#8220;parent&#8221; type).</p>
</div>
<div class="slide">
<h1>Covariant and Contravariant Behaviors (cont.)</h1>
<p>So, what does this mean for <code>Function1[-A,+R]</code>? First consider the <code>+R</code> for the return value, which behaves <em>covariantly</em>. In our example, we defined a function this way:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val s2o: (String =&gt; Output) = s =&gt; new Output("out" + s)
</pre></div>
<p>Suppose we define a new function that returns <code>LineOrientedOutput</code>:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val s2loo: (String =&gt; LineOrientedOutput) = 
  s =&gt; new LineOrientedOutput("out" + s)

def toOutputs ... // same

val outputs: List[Output] = toOutputs(List("A", "B"), s2loo)
// returns: List[Output] = List(LineOrientedOutput(outA), LineOrientedOutput(outB))
</pre></div>
<p>This works fine!</p>
</div>
<div class="slide">
<h1>Covariant Behavior of Return Values</h1>
<p><code>s2loo</code> <em>always</em> returns a <code>LineOrientedOutput</code>. That&#8217;s fine, because the clients that use <code>toOutputs</code> expect a <code>List[Output]</code> and <code>List[LineOrientedOutput]</code> is a subtype.</p>
<p>This is why return values must be <em>covariant</em>.</p>
<p>So, <code>s2loo</code> of type <code>Function[String,LineOrientedOutput]</code> is a <em>subtype</em> of <code>Function1[String,Output]</code>, since <code>LineOrientedOutput</code> is a <em>subtype</em> of <code>Output</code>.</p>
</div>
<div class="slide">
<h1>Contravariant Behavior of Arguments</h1>
<p>Now consider what we can do with the arguments, which behave <em>contravariantly</em>, since <code>Function1</code> is declared <code>Function1[-A,+R]</code>.</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

val a2o: (Any =&gt; Output) = 
  s =&gt; new Output("out" + s.toString)

def toOutputs ... // same

val outputs: List[Output] = toOutputs(List("A", "B"), a2o)
// returns: List[Output] = List(LineOrientedOutput(outA), LineOrientedOutput(outB))
</pre></div>
<p>This also works!</p>
</div>
<div class="slide">
<h1>Contravariant Behavior of Arguments</h1>
<p>Why does it work? <code>toOutputs</code> only accepts a <code>List[String]</code> as the first argument. Each string will be passed to the 2nd argument, the transformation function which creates an <code>Output</code>. In this case, <code>a2o</code> is that function. It can handle <code>Any</code> object, so it can easily handle strings. Hence, no breakage.</p>
<p>So, <code>a2o</code> of type <code>Function[Any,Output]</code> is also a <em>subtype</em> of <code>Function1[String,Output]</code>, even though <code>Any</code> is a <em>supertype</em> of <code>String</code>.</p>
</div>
<div class="slide">
<h1><span class="caps">LSP</span> and Design by Contract</h1>
<p>Remember that we&#8217;re describing the way that <code>Function1.apply</code> behaves under inheritance.</p>
<p><span class="caps">LSP</span> says that we can substitute an object if it <em>broadens</em> the allowed input values its methods can handle, because clients will still only pass the subset of values the <em>preconditions</em> say are acceptable. Hence, the precondition contract is preserved.</p>
<p>Similarly, an object is substitutable if its methods return a <em>narrower</em> set of values, because that set will always be within a broader set the client expects, as defined by the <em>postconditions</em>.</p>
<p>That&#8217;s how <span class="caps">LSP</span> and Design by Contract are related.</div></p>

  <!-- Syntax Highlighter -->
  <script language="javascript" type="text/javascript" src="../lib/scripts/shCore.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushBash.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCpp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCSharp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCss.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushDelphi.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushJava.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushJScript.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPhp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPlain.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPython.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushRuby.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushScala.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushSql.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushVb.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushXml.js"></script>
  <script language="javascript">
    SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
    SyntaxHighlighter.all();
  </script>
</div>
</body>
</html>
