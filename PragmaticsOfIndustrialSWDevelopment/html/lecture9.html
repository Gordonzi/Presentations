<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Pragmatics of Industrial Software Development</title>
<!-- metadata -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<meta name="date" content="August 5, 2010" />
<meta name="author" content="Dean Wampler, Ph.D." />
<meta name="company" content="Department of Computer Science,<br/>Loyola University Chicago" />
<meta name="copyright" content="2010 Dean Wampler, All Rights Reserved" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="../ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="../ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="../lib/stylesheets/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="../ui/default/opera.css" type="text/css" media="projection" id="operaFix" />

<link rel="stylesheet" href="../lib/stylesheets/pressie.css" type="text/css" />

<!-- S5 JS -->
<script src="../ui/default/slides.js" type="text/javascript"></script>

<!-- Syntax Highlighter -->
<!-- <link rel="stylesheet"  href="../lib/stylesheets/SyntaxHighlighter.css"></link> -->
<link type="text/css" rel="stylesheet" href="../lib/stylesheets/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../lib/stylesheets/shThemeDefault.css"/>


</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h2>Copyright &copy; 2010 Dean Wampler, All Rights Reserved</h2>
<h2>August 5, 2010</h2>
</div>

</div>


<div class="presentation">
<div class="slide">
<h1>Lecture 9: Effective Object-Oriented Programming (<span class="caps">OOP</span>), Part II</h1>
</div>
<div class="slide">
<h1>Why Are Objects Interesting?</h1>
<p>Because managing complexity is one of our biggest challenges. Mentally, we object encapsulation in our daily lives to avoid being overwhelmed by sensory input. Object-Oriented Programming tries to apply that same strategy to managing software complexity.</p>
</div>
<div class="slide">
<h1>Some History</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 1967 </td>
		<td> Simula </td>
		<td> Objects, classes, subclasses, virtual methods, coroutines, discrete event simulation, garbage collection. </td>
		<td> First OO Language.</td>
	</tr>
	<tr>
		<td> 1972 </td>
		<td> Smalltalk </td>
		<td> Object-oriented, dynamically typed, reflective. </td>
		<td> First public version in 1980</td>
	</tr>
</table>
</div>
</div>
<div class="slide">
<h1>Some History (cont.)</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 1983 </td>
		<td> C++ </td>
		<td> Classes, virtual functions, operator overloading, multiple inheritance, templates. </td>
		<td> Most widely used OO language in the 90s. (?) </td>
	</tr>
	<tr>
		<td> 1986 </td>
		<td> Eiffel </td>
		<td> Design by contract, command-query separation, uniform-access principle, single-choice principle, open-closed principle, and option-operand separation </td>
		<td> Very innovative. Still used in some industries, esp. in Europe.</td>
	</tr>
</table>
<p>In 1984, Apple introduced the Macintosh, the first popular copmuter with a Graphical User Interface. GUIs were quickly seen as ideal for <span class="caps">OOP</span>.</p>
</div>
</div>
<div class="slide">
<h1>Some History (cont.)</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 1995 </td>
		<td> Java </td>
		<td> &#8220;Simplified C++&#8221;, plus byte code running on a virtual machine. </td>
		<td> Rapid adoption with the Internet. </td>
	</tr>
	<tr>
		<td> 1995 </td>
		<td> JavaScript </td>
		<td> Prototype-based, scripting, dynamically and weakly typed, first-class functions, closures, higher-order functions. </td>
		<td> Also considered a functional programming language. Inspired by Scheme. </td>
	</tr>
</table>
</div>
</div>
<div class="slide">
<h1>Some History (cont.)</h1>
<div class='small'>
<table>
	<tr>
		<th>Year </th>
		<th>Event</th>
		<th>Features</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td> 2003 </td>
		<td> Scala </td>
		<td> Object-oriented and functional programming. </td>
		<td> Runs on the <span class="caps">JVM</span> and .<span class="caps">NET</span> <span class="caps">CLR</span>. </td>
	</tr>
	<tr>
		<td> 2007 </td>
		<td> Clojure </td>
		<td> Lisp on the <span class="caps">JVM</span>. </td>
		<td> Innovative approaches to mutable state. </td>
	</tr>
</table>
</div>
</div>
<div class="slide">
<h1>Eiffel Innovations</h1>
<ul>
	<li><strong>Design by Contract:</strong> Discussed last lecture.</li>
	<li><strong>Command-Query Separation:</strong></li>
	<li><strong>Uniform-Access Principle:</strong></li>
	<li><strong>Single-Choice Principle:</strong></li>
	<li><strong>Open-Closed Principle:</strong></li>
	<li><strong>Option-Operand Separation:</strong> (We won&#8217;t discuss this one.)</li>
</ul>
</div>
<div class="slide">
<h1>Command-Query Separation</h1>
<p>To keep each &#8220;piece&#8221; of code as simple as possible, each object and function should <em>do only one &#8220;thing&#8221;</em>. This is the <em>Single Responsibility Principle</em>, the &#8220;S&#8221; in the <span class="caps">SOLID</span> principles.</p>
</div>
<div class="slide">
<h1>Command-Query Separation (cont.)</h1>
<p>If a function executes a &#8220;command&#8221; and it returns a value (&#8220;query&#8221;), it&#8217;s doing <em>two</em> things. Hence, you should have separate command and query functions:</p>
<ul>
	<li><strong>Command:</strong> Do something, i.e., update state, but don&#8217;t return values. (It might return a &#8220;success&#8221; indicator&#8230;)</li>
	<li><strong>Query:</strong> Return a result, but don&#8217;t alter state (at least not the visible state &#8211; it may update an internal <em>cache</em>, for example.)</li>
</ul>
<p>Example: JavaBean getters and setters.</p>
</div>
<div class="slide">
<h1>Uniform-Access Principle</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

case class Person(name:String, age: Int)
...
val dean = Person("Dean Wampler")
println(dean.name)
</pre></div>
<p>Am I calling a method <code>name</code> or accessing a &#8220;bare&#8221; <code>name</code> field??</p>
</div>
<div class="slide">
<h1>Uniform-Access Principle (cont.)</h1>
<p>The <em>caller</em> doesn&#8217;t care whether a method is invoked or a bare field is accessed.</p>
<p>The <em>implementer</em> might want to start with a simple bare field access, then eventually replace it with a method call (e.g., to do lazy initialization, etc.).</p>
<p>The <em>uniform-access principle</em> means the caller&#8217;s code doesn&#8217;t have to change, because the syntax is identical. (The code might need a recompile).</p>
</div>
<div class="slide">
<h1>Uniform-Access Principle (cont.)</h1>
<p>Note that the JavaBean convention for getters and setters does <em>not</em> support this principle!</p>
<div class="code-small">
<pre name="code" id="code" class="brush: java,;">

class Person {
  private String name;
  public String getName() { return name; }
  
  public Person(String name) { this.name = name; }
}
...
val dean = Person("Dean Wampler")
println(dean.getName());
// very different from:
// println(dean.name);
</pre></div>
</div>
<div class="slide">
<h1>Single-Choice Principle</h1>
<p>This is now more commonly known as <span class="caps">DRY</span>, <em>Don&#8217;t Repeat Yourself</em>. It means, don&#8217;t write code that duplicates the work of other code.</p>
<ul>
	<li>Leads to bloat.</li>
	<li>Each version must be maintained, kept in sync.
	<ul>
		<li>It&#8217;s very common for the versions to &#8220;grow&#8221; out of sync, leading to bugs.</li>
	</ul></li>
</ul>
</div>
<div class="slide">
<h1>Open-Closed Principle</h1>
<p>The &#8220;O&#8221; in the <span class="caps">SOLID</span> principles.</p>
<p>How can we add new behavior to the system without editing existing code? Philip Wadler called this the <em>Expression Problem</em>.</p>
<ul>
	<li>If we edit existing code,</li>
	<li>we must retest, redeploy&#8230;</li>
	<li>we force clients of the code to modify their code and retest, redeploy&#8230;</li>
</ul>
</div>
<div class="slide">
<h1>Open-Closed Principle (cont.)</h1>
<p>Inheritance is a classic way to do this. Our windowing example demonstrates this:</p>
<center>
<span style="width: 100%;">
<img src="images/Windows_WindowsFactories.png"></img>
</span>
</center>
<p>We could add iPhone and Android classes, for example, without changing any existing classes&#8230; in principle&#8230;</p>
</div>
<div class="slide">
<h1>Open-Closed Principle (cont.)</h1>
<p>In practice, when you introduce new subclasses, the existing abstractions may not fully support their needs, forcing some changes on the existing types. Hopefully, that&#8217;s rare.</p>
</div>
<div class="slide">
<h1>Open-Closed Principle (cont.)</h1>
<p>We&#8217;ll return to this principle when we talk about <em>Type Classes</em>.</p>
</div>
<div class="slide">
<h1>Strong Coupling</h1>
<p>Last time, we talked at length about encapsulation. We also mentioned that it helps minimize coupling between modules. Some of the principles we just discussed also do this. Let&#8217;s explore coupling some more.</p>
<center>
<p><img src="images/Module_Dependencies.png"></img></p>
</center>
<p>Is it bad if <code>GUI</code> depends on <code>MacWindowFactory</code>??</p>
</div>
<div class="slide">
<h1><code>gui.windowing</code></h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package gui.windowing {

  abstract class Window(dimensions: Dimensions) {...}  
  abstract class WindowFactory {
    def make(properties: Properties): Window
  }
  
  protected[gui] package mac {
    MacWindow(...) extends Window(...) {...}
    object MacWindowFactory extends WindowFactory {
      def make(properties: Properties): Window = {...}
    }
  }
  protected[gui] package windows {
    WindowsWindow(...) extends Window(...) {...}
    ...
  }
  ...
}
</pre></div>
</div>
<div class="slide">
<h1>Other <span class="caps">GUI</span> Modules</h1>
<p><span class="caps">BAD</span>:<br />
<div class="code-small"></p>

<pre name="code" id="code" class="brush: scala,;">

package gui.windowing {
  def makeNewWindow(properties: Properties) {
    val window = mac.MacWindowFactory.make(properties)
    // Other Mac-specific calls...
  }
}
</pre></div>
<p><span class="caps">GOOD</span>:<br />
<div class="code-small"></p>

<pre name="code" id="code" class="brush: scala,;">

package gui.windowing {
  def makeNewWindow(properties: Properties) {
    val window = WindowFactory.make(properties)
    // Other generic calls...
  }
}
</pre></div>
</div>
<div class="slide">
<h1>Why is Strong Coupling Bad</h1>
<ul>
	<li><strong>Testing</strong></li>
	<li><strong>Maintenance</strong></li>
</ul>
</div>
<div class="slide">
<h1>Testing</h1>
<p>If I want to test a module, I have to set up all its dependencies. That&#8217;s painful if the dependencies are database connections, user interfaces, external processes, etc.</p>
<p>For example, I could only test <code>makeNewWindow</code> with a Macintosh. Also, creating windows is much slower than just &#8220;running code&#8221;.</p>
<p>But if <code>makeNewWindow</code> depends only on interfaces, I can use <em>stub</em> implementations that make testing easy and fast.</p>
</div>
<div class="slide">
<h1>Maintenance</h1>
<p>If you have several other teams that depend on the implementation of <code>MacWindowFactory</code>, you can&#8217;t change it without pain:</p>
<ul>
	<li>You have to plan with those teams when to introduce the changes.</li>
	<li>You and they have to coordinate the changes.</li>
	<li>They have to <em>unit</em> test their changes in isolation.</li>
	<li>The organization has to <em>integration</em> test the changes.</li>
	<li>All the changes need to be deployed in a coordinated manner.</li>
</ul>
</div>
<div class="slide">
<h1>Inheritance Is Strong Coupling</h1>
<p>It&#8217;s important to note that <em>inheritance is a form of strong coupling</em>. (About the strongest in fact.) The advantages vs. disadvantages need to be weighed.</p>
<p><strong>Advantages:</strong></p>
<ul>
	<li>Reuse of state and behavior.</li>
	<li>Grouping of &#8220;logically-similar&#8221; things.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
	<li>Any change to parent may require changes to child.</li>
	<li>Proper implementations of <code>clone</code>, <code>equals</code>, <code>hashCode</code> challenging.</li>
</ul>
<p>Like any form of coupling, it should be used <em>sparingly</em>.</p>
</div>
<div class="slide">
<h1>Composition vs. Inheritance</h1>
<p>Compare the following approaches:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

abstract class Addressable(
  ..., val city:String, val state:String, val zip:ZipCode)
  
case class Person(name:String, age: Int)
  extends Addressable
</pre></div>
<p>Does <code>Person</code> <em>behave as</em> an <code>Addressable</code>? What does <em>that</em> mean?</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

class Address(
  ..., val city:String, val state:String, val zip:ZipCode)
  
case class Person(name:String, age: Int, address: Address)
</pre></div>
<p>Makes more sense to say <code>Person</code> <em>has an</em> <code>Address</code>.</p>
</div>
<div class="slide">
<h1>Less Trivial Example:</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package graphics {
  // Abstraction
  trait Rectangle {...}
}
package opengl {
  // Concrete implementation.
  class OGLRectangle(val lowerLeft: Point, val upperRight: Point) 
    extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // Inherits concrete implementation
  class X11Window(properties: Properties) 
    extends opengl.OGLRectangle(...) {...}
}
</pre></div>
</div>
<div class="slide">
<h1>Versus:</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package graphics {
  // Abstraction
  trait Rectangle {...}  
}
package opengl {
  // Concrete implementation.
  class OGLRectangle(val lowerLeft: Point, val upperRight: Point) 
    extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // Uses an object implementing abstraction.
  class X11Window(properties: Properties, rect: Rectangle) {...} 
}
</pre></div>
<p>We <em>compose</em> the X11 window with an implementing rectangle.</p>
</div>
<div class="slide">
<h1>Composition vs. Inheritance (cont.)</h1>
<p>So, coupling to abstractions is the weakest form of dependency. Therefore, we should prefer <em>composing</em> behavior over <em>inheriting</em> it.</p>
<p><strong>Object Properties:</strong></p>
<p>Every property is a reference to another object (as long as you consider, numbers, booleans, etc. objects&#8230;)</p>
</div>
<div class="slide">
<h1>Mixins</h1>
<p>An alternative to using <em>properties</em> is to use <em>mixins</em>, which are like standalone objects (they have their own <em>behavior</em>: state and/or functions), but they are designed to be mixed into other objects, adding additional behavior.</p>
<p>Most of the time, these behaviors will be <em>orthogonal</em>.</p>
<center>
<span style="width: 100%;">
<img src="images/StateSpace.png"></img>
</span>
</center>
</div>
<div class="slide">
<h1>Example: Logging Mixin</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package utils {
  trait Logging {
    def error(message: String) = {...}
    def warning(message: String) = {...}
    def info(message: String) = {...}
  }
}

package gui.windowing.x11 {  
  // Make all windows with logging mixed in:
  object X11WindowFactory extends WindowFactory { 
    def make(properties: Properties) = {
      val dimensions = // get dimensions from properties
      new X11Window(dimensions) with utils.Logging
    } // returns window WITH Logging mixed in!
  } 
}
</pre></div>
</div>
<div class="slide">
<h1>Mixins (cont.)</h1>
<p>Other times, the mixin behavior may be closely linked to the class.</p>
<p>Example: How could you model the M:N relationship between windowing toolkits (e.g., Xll, Windows, Aqua, etc.) and the low-level graphics APIs (e.g., OpenGL, DirectX, Quartz, etc.)</p>
</div>
<div class="slide">
<h1>Joining <span class="caps">GUI</span> and Graphics Libs</h1>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

package graphics { // for any graphics library...
  trait Rectangle {  // abstraction of rectangle.
    val lowerLeft: Point  // traits don't have constructors,
    val upperRight: Point // ... so we declare "fields" here.
    ...
  }
}
package opengl {  // OpenGL-specific "driver"
  trait OGLRectangle extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // "self type" declaration:
  // X11Window will be composed with a Rectangle...
  abstract class X11Window(properties: Properties) { 
    self: Rectangle =&gt;
    ...
  } 
}
</pre></div>
</div>
<div class="slide">
<h1>Self Types in Scala</h1>
<p><em>Self type declarations</em>, like this:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

abstract class X11Window(properties: Properties) { 
  self: Rectangle =&gt;
  ...
}
</pre></div>
<p>are &#8220;promises&#8221; that any <em>concrete</em> class eventually created from <code>X11Window</code> will mix in a Rectangle trait. In byte code, it is identical to <code>X11Window extends Rectangle</code>, but avoids the <em>is a</em> trap (Liskov).</p>
</div>
<div class="slide">
<h1>Self Types in Scala</h1>
<p>In other words, we could write it this way:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

abstract class X11Window(properties: Properties) extends Rectangle { 
  ...
}
</pre></div>
<p>but that implies that window is substitutable for Rectangle (Liskov), which is a poor inheritance relationship.</p>
<p>Self types emphasize instead that we will get the &#8220;Rectangle&#8221; behavior we need through a mixin.</p>
</div>
<div class="slide">
<h1>Instantiating the Objects</h1>
<p>So, to create actual objects the factory method would do this:</p>
<div class="code-small">
<pre name="code" id="code" class="brush: scala,;">

object X11WindowFactory extends WindowFactory { 
  def make(properties: Properties) = {
    val dimensions = // get dimensions from properties
    new X11Window(dimensions) with utils.Logging with OGLRectangle {
      val lowerLeft = // get it from the dimensions
      val upperRight = // get it from the dimensions
    }
  } // returns window WITH Logging WITH OGLRectangle!
} 
</pre></div>
<p>Note: this technique is called the <a href="http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di.html">Cake Pattern</a> (also discussed <a href="http://programming-scala.labs.oreilly.com/ch13.html">here</a> and used to <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5834&amp;rep=rep1&amp;type=pdf">implement the Scala compiler itself</a>)</p>
</div>
<div class="slide">
<h1>Problems with Objects</h1>
</div>
<div class="slide">
<h1>Clone</h1>
</div>
<div class="slide">
<h1>Equals</h1>
</div>
<div class="slide">
<h1>Typing</h1>
</div>
<div class="slide">
<h1><span class="caps">LSP</span> revisited</h1>
<p>Covariant and Contravariant behaviors.</p>
</div>
<div class="slide">
<h1>Concurrency</div></h1>

  <!-- Syntax Highlighter -->
  <script language="javascript" type="text/javascript" src="../lib/scripts/shCore.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushBash.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCpp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCSharp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushCss.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushDelphi.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushJava.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushJScript.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPhp.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPlain.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushPython.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushRuby.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushScala.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushSql.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushVb.js"></script>
  <script language="javascript" type="text/javascript" src="../lib/scripts/shBrushXml.js"></script>
  <script language="javascript">
    SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
    SyntaxHighlighter.all();
  </script>
</div>
</body>
</html>
