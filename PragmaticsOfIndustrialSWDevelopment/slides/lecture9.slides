h1. Lecture 9: Effective Object-Oriented Programming (OOP), Part II

h1. Why Are Objects Interesting?

Because managing complexity is one of our biggest challenges. Mentally, we object encapsulation in our daily lives to avoid being overwhelmed by sensory input. Object-Oriented Programming tries to apply that same strategy to managing software complexity.

h1. Some History

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 1967 | Simula | Objects, classes, subclasses, virtual methods, coroutines, discrete event simulation, garbage collection. | First OO Language.|
| 1972 | Smalltalk | Object-oriented, dynamically typed, reflective. | First public version in 1980|

</div>

h1. Some History (cont.)

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 1983 | C++ | Classes, virtual functions, operator overloading, multiple inheritance, templates. | Most widely used OO language in the 90s. (?) |
| 1986 | Eiffel | Design by contract, command-query separation, uniform-access principle, single-choice principle, open-closed principle, and option-operand separation | Very innovative. Still used in some industries, esp. in Europe.|

In 1984, Apple introduced the Macintosh, the first popular copmuter with a Graphical User Interface. GUIs were quickly seen as ideal for OOP.

</div>

h1. Some History (cont.)

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 1995 | Java | "Simplified C++", plus byte code running on a virtual machine. | Rapid adoption with the Internet. |
| 1995 | JavaScript | Prototype-based, scripting, dynamically and weakly typed, first-class functions, closures, higher-order functions. | Also considered a functional programming language. Inspired by Scheme. |

</div>

h1. Some History (cont.)

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 2003 | Scala | Object-oriented and functional programming. | Runs on the JVM and .NET CLR. |
| 2007 | Clojure | Lisp on the JVM. | Innovative approaches to mutable state. |

</div>

h1. Eiffel Innovations

* *Design by Contract:* Discussed last lecture.
* *Command-Query Separation:*
* *Uniform-Access Principle:*
* *Single-Choice Principle:*
* *Open-Closed Principle:* 
* *Option-Operand Separation:*

h1. Command-Query Separation

To keep each "piece" of code as simple as possible, each object and function should _do only one "thing"_. This is the _Single Responsibility Principle_, the "S" in the SOLID principles.

h1. Command-Query Separation (cont.)

If a function executes a "command" and it returns a value ("query"), it's doing _two_ things. Hence, you should have separate command and query functions:

* *Command:* Do something, i.e., update state, but don't return values. (It might return a "success" indicator...)
* *Query:* Return a result, but don't alter state (at least not the visible state - it may update an internal _cache_, for example.)

Example: JavaBean getters and setters.

h1. Uniform-Access Principle

:inlinecode lang=scala, class=code-small
case class Person(name:String, age: Int)
...
val dean = Person("Dean Wampler")
println(dean.name)
:endinlinecode 

Am I calling a method @name@ or accessing a "bare" @name@ field??

h1. Uniform-Access Principle (cont.)

The _caller_ doesn't care whether a method is invoked or a bare field is accessed.
 
The _implementer_ might want to start with a simple bare field access, then eventually replace it with a method call (e.g., to do lazy initialization, etc.).

The _uniform-access principle_ means the caller's code doesn't have to change, because the syntax is identical. (The code might need a recompile).

h1. Uniform-Access Principle (cont.)

Note that the JavaBean convention for getters and setters does _not_ support this principle!

:inlinecode lang=java, class=code-small
class Person {
  private String name;
  public String getName() { return name; }
  
  public Person(String name) { this.name = name; }
}
...
val dean = Person("Dean Wampler")
println(dean.getName());
// very different from:
// println(dean.name);
:endinlinecode 

h1. Single-Choice Principle

h1. Open-Closed Principle

The "O" in the SOLID principles.

We'll return to this principle when we talk about _the Expression Problem_ and _Type Classes_.

h1. Option-Operand Separation

h1. Strong Coupling

Last time, we talked at length about encapsulation. We also mentioned that it helps minimize coupling between modules. Let's explore this topic further.

<center>
	<img src="images/Module_Dependencies.png"></img>
</center>

Is it bad if @GUI@ depends on @MacWindowFactory@??

h1. @gui.windowing@

:inlinecode lang=scala, class=code-small
package gui.windowing {

  abstract class Window(dimensions: Dimensions) {...}  
  abstract class WindowFactory {
    def make(dimensions: Dimensions): Window
  }
  
  protected[gui] package mac {
    MacWindow(...) extends Window(...) {...}
    object MacWindowFactory extends WindowFactory {
      def make(properties: Properties): Window = {...}
    }
  }
  protected[gui] package windows {
    WindowsWindow(...) extends Window(...) {...}
    ...
  }
  ...
}
:endinlinecode 

h1. Other GUI Modules

BAD:
:inlinecode lang=scala, class=code-small
package gui.windowing {
  def makeNewWindow(properties: Properties) {
    val window = mac.MacWindowFactory.make(properties)
    // Other Mac-specific calls...
  }
}
:endinlinecode 

GOOD:
:inlinecode lang=scala, class=code-small
package gui.windowing {
  def makeNewWindow(properties: Properties) {
    val window = WindowFactory.make(properties)
    // Other generic calls...
  }
}
:endinlinecode 


h1. Why is Strong Coupling Bad

* *Testing*
* *Maintenance*

h1. Testing

If I want to test a module, I have to set up all its dependencies. That's painful if the dependencies are database connections, user interfaces, external processes, etc.

For example, I could only test @makeNewWindow@ with a Macintosh. Also, creating windows is much slower than just "running code".

But if @makeNewWindow@ depends only on interfaces, I can use _stub_ implementations that make testing easy and fast.

h1. Maintenance

If you have several other teams that depend on the implementation of @MacWindowFactory@, you can't change it without pain:

* You have to plan with those teams when to introduce the changes.
* You and they have to coordinate the changes.
* They have to _unit_ test their changes in isolation.
* The organization has to _integration_ test the changes.
* All the changes need to be deployed in a coordinated manner.

h1. Inheritance Is Strong Coupling

It's important to note that _inheritance is a form of strong coupling_. (About the strongest in fact.) The advantages vs. disadvantages need to be weighed.

*Advantages:*
* Reuse of state and behavior.
* Grouping of "logically-similar" things.

*Disadvantages:*
* Any change to parent may require changes to child.
* Proper implementations of @clone@, @equals@, @hashCode@ challenging.

Like any form of coupling, it should be used _sparingly_.

h1. Composition vs. Inheritance

Mixins.

h1. Problems with Objects

h1. Clone

h1. Equals

h1. Typing

h1. LSP revisited

Covariant and Contravariant behaviors.

h1. Concurrency

