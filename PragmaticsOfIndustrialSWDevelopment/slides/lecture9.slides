h1. Lecture 9: Effective Object-Oriented Programming (OOP), Part II

h1. Why Are Objects Interesting?

Because managing complexity is one of our biggest challenges. Mentally, we object encapsulation in our daily lives to avoid being overwhelmed by sensory input. Object-Oriented Programming tries to apply that same strategy to managing software complexity.

h1. Some History

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 1967 | Simula | Objects, classes, subclasses, virtual methods, coroutines, discrete event simulation, garbage collection. | First OO Language.|
| 1972 | Smalltalk | Object-oriented, dynamically typed, reflective. | First public version in 1980|

</div>

h1. Some History (cont.)

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 1983 | C++ | Classes, virtual functions, operator overloading, multiple inheritance, templates. | Most widely used OO language in the 90s. (?) |
| 1986 | Eiffel | Design by contract, command-query separation, uniform-access principle, single-choice principle, open-closed principle, and option-operand separation | Very innovative. Still used in some industries, esp. in Europe.|

In 1984, Apple introduced the Macintosh, the first popular copmuter with a Graphical User Interface. GUIs were quickly seen as ideal for OOP.

</div>

h1. Some History (cont.)

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 1995 | Java | "Simplified C++", plus byte code running on a virtual machine. | Rapid adoption with the Internet. |
| 1995 | JavaScript | Prototype-based, scripting, dynamically and weakly typed, first-class functions, closures, higher-order functions. | Also considered a functional programming language. Inspired by Scheme. |

</div>

h1. Some History (cont.)

<div class='small'>

|_.Year |_.Event|_.Features|_.Notes|
| 2003 | Scala | Object-oriented and functional programming. | Runs on the JVM and .NET CLR. |
| 2007 | Clojure | Lisp on the JVM. | Innovative approaches to mutable state. |

</div>

h1. Eiffel Innovations

* *Design by Contract:* Discussed last lecture.
* *Command-Query Separation:*
* *Uniform-Access Principle:*
* *Single-Choice Principle:*
* *Open-Closed Principle:* 
* *Option-Operand Separation:* (We won't discuss this one.)

h1. Command-Query Separation

To keep each "piece" of code as simple as possible, each object and function should _do only one "thing"_. This is the _Single Responsibility Principle_, the "S" in the SOLID principles.

h1. Command-Query Separation (cont.)

If a function executes a "command" and it returns a value ("query"), it's doing _two_ things. Hence, you should have separate command and query functions:

* *Command:* Do something, i.e., update state, but don't return values. (It might return a "success" indicator...)
* *Query:* Return a result, but don't alter state (at least not the visible state - it may update an internal _cache_, for example.)

Example: JavaBean getters and setters.

h1. Uniform-Access Principle

:inlinecode lang=scala, class=code-small
case class Person(name:String, age: Int)
...
val dean = Person("Dean Wampler")
println(dean.name)
:endinlinecode 

Am I calling a method @name@ or accessing a "bare" @name@ field??

h1. Uniform-Access Principle (cont.)

The _caller_ doesn't care whether a method is invoked or a bare field is accessed.
 
The _implementer_ might want to start with a simple bare field access, then eventually replace it with a method call (e.g., to do lazy initialization, etc.).

The _uniform-access principle_ means the caller's code doesn't have to change, because the syntax is identical. (The code might need a recompile).

h1. Uniform-Access Principle (cont.)

Note that the JavaBean convention for getters and setters does _not_ support this principle!

:inlinecode lang=java, class=code-small
class Person {
  private String name;
  public String getName() { return name; }
  
  public Person(String name) { this.name = name; }
}
...
val dean = Person("Dean Wampler")
println(dean.getName());
// very different from:
// println(dean.name);
:endinlinecode 

h1. Single-Choice Principle

This is now more commonly known as DRY, _Don't Repeat Yourself_. It means, don't write code that duplicates the work of other code.

* Leads to bloat.
* Each version must be maintained, kept in sync.
** It's very common for the versions to "grow" out of sync, leading to bugs.

h1. Open-Closed Principle

The "O" in the SOLID principles.

How can we add new behavior to the system without editing existing code? Philip Wadler called this the _Expression Problem_.

* If we edit existing code, 
* we must retest, redeploy...
* we force clients of the code to modify their code and retest, redeploy...

h1. Open-Closed Principle (cont.)

Inheritance is a classic way to do this. Our windowing example demonstrates this:

<center>
  <span style="width: 100%;">
    <img src="images/Windows_WindowsFactories.png"></img>
  </span>
</center>

We could add iPhone and Android classes, for example, without changing any existing classes... in principle...

h1. Open-Closed Principle (cont.)

In practice, when you introduce new subclasses, the existing abstractions may not fully support their needs, forcing some changes on the existing types. Hopefully, that's rare.

h1. Open-Closed Principle (cont.)

We'll return to this principle when we talk about _Type Classes_.

h1. Strong Coupling

Last time, we talked at length about encapsulation. We also mentioned that it helps minimize coupling between modules. Some of the principles we just discussed also do this. Let's explore coupling some more.

<center>
	<img src="images/Module_Dependencies.png"></img>
</center>

Is it bad if @GUI@ depends on @MacWindowFactory@??

h1. @gui.windowing@

:inlinecode lang=scala, class=code-small
package gui.windowing {

  abstract class Window(dimensions: Dimensions) {...}  
  abstract class WindowFactory {
    def make(properties: Properties): Window
  }
  
  protected[gui] package mac {
    MacWindow(...) extends Window(...) {...}
    object MacWindowFactory extends WindowFactory {
      def make(properties: Properties): Window = {...}
    }
  }
  protected[gui] package windows {
    WindowsWindow(...) extends Window(...) {...}
    ...
  }
  ...
}
:endinlinecode 

h1. Other GUI Modules

BAD:
:inlinecode lang=scala, class=code-small
package gui.windowing {
  def makeNewWindow(properties: Properties) {
    val window = mac.MacWindowFactory.make(properties)
    // Other Mac-specific calls...
  }
}
:endinlinecode 

GOOD:
:inlinecode lang=scala, class=code-small
package gui.windowing {
  def makeNewWindow(properties: Properties) {
    val window = WindowFactory.make(properties)
    // Other generic calls...
  }
}
:endinlinecode 


h1. Why is Strong Coupling Bad

* *Testing*
* *Maintenance*

h1. Testing

If I want to test a module, I have to set up all its dependencies. That's painful if the dependencies are database connections, user interfaces, external processes, etc.

For example, I could only test @makeNewWindow@ with a Macintosh. Also, creating windows is much slower than just "running code".

But if @makeNewWindow@ depends only on interfaces, I can use _stub_ implementations that make testing easy and fast.

h1. Maintenance

If you have several other teams that depend on the implementation of @MacWindowFactory@, you can't change it without pain:

* You have to plan with those teams when to introduce the changes.
* You and they have to coordinate the changes.
* They have to _unit_ test their changes in isolation.
* The organization has to _integration_ test the changes.
* All the changes need to be deployed in a coordinated manner.

h1. Inheritance Is Strong Coupling

It's important to note that _inheritance is a form of strong coupling_. (About the strongest in fact.) The advantages vs. disadvantages need to be weighed.

*Advantages:*
* Reuse of state and behavior.
* Grouping of "logically-similar" things.

*Disadvantages:*
* Any change to parent may require changes to child.
* Proper implementations of @clone@, @equals@, @hashCode@ challenging.

Like any form of coupling, it should be used _sparingly_.

h1. Composition vs. Inheritance

Compare the following approaches:

:inlinecode lang=scala, class=code-small
abstract class Addressable(
  ..., val city:String, val state:String, val zip:ZipCode)
  
case class Person(name:String, age: Int)
  extends Addressable
:endinlinecode 

Does @Person@ _behave as_ an @Addressable@? What does _that_ mean?

:inlinecode lang=scala, class=code-small
class Address(
  ..., val city:String, val state:String, val zip:ZipCode)
  
case class Person(name:String, age: Int, address: Address)
:endinlinecode 

Makes more sense to say @Person@ _has an_ @Address@.

h1. Less Trivial Example:

:inlinecode lang=scala, class=code-small
package graphics {
  // Abstraction
  trait Rectangle {...}
}
package opengl {
  // Concrete implementation.
  class OGLRectangle(val lowerLeft: Point, val upperRight: Point) 
    extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // Inherits concrete implementation
  class X11Window(properties: Properties) 
    extends opengl.OGLRectangle(...) {...}
}
:endinlinecode 


h1. Versus:

:inlinecode lang=scala, class=code-small
package graphics {
  // Abstraction
  trait Rectangle {...}  
}
package opengl {
  // Concrete implementation.
  class OGLRectangle(val lowerLeft: Point, val upperRight: Point) 
    extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // Uses an object implementing abstraction.
  class X11Window(properties: Properties, rect: Rectangle) {...} 
}
:endinlinecode 

We _compose_ the X11 window with an implementing rectangle.

h1. Composition vs. Inheritance (cont.)

So, coupling to abstractions is the weakest form of dependency. Therefore, we should prefer _composing_ behavior over _inheriting_ it.

*Object Properties:*

Every property is a reference to another object (as long as you consider, numbers, booleans, etc. objects...)

h1. Mixins

An alternative to using _properties_ is to use _mixins_, which are like standalone objects (they have their own _behavior_: state and/or functions), but they are designed to be mixed into other objects, adding additional behavior.

Most of the time, these behaviors will be _orthogonal_.

<center>
  <span style="width: 100%;">
    <img src="images/StateSpace.png"></img>
  </span>
</center>

h1. Example: Logging Mixin

:inlinecode lang=scala, class=code-small
package utils {
  trait Logging {
    def error(message: String) = {...}
    def warning(message: String) = {...}
    def info(message: String) = {...}
  }
}

package gui.windowing.x11 {  
  // Make all windows with logging mixed in:
  object X11WindowFactory extends WindowFactory { 
    def make(properties: Properties) = {
      val dimensions = // get dimensions from properties
      new X11Window(dimensions) with utils.Logging
    } // returns window WITH Logging mixed in!
  } 
}
:endinlinecode 


h1. Mixins (cont.)

Other times, the mixin behavior may be closely linked to the class.

Example: How could you model the M:N relationship between windowing toolkits (e.g., Xll, Windows, Aqua, etc.) and the low-level graphics APIs (e.g., OpenGL, DirectX, Quartz, etc.)

h1. Joining GUI and Graphics Libs

:inlinecode lang=scala, class=code-small
package graphics { // for any graphics library...
  trait Rectangle {  // abstraction of rectangle.
    val lowerLeft: Point  // traits don't have constructors,
    val upperRight: Point // ... so we declare "fields" here.
    ...
  }
}
package opengl {  // OpenGL-specific "driver"
  trait OGLRectangle extends graphics.Rectangle {...}
}
package gui.windowing.x11 {  
  // "self type" declaration:
  // X11Window will be composed with a Rectangle...
  abstract class X11Window(properties: Properties) { 
    self: Rectangle =>
    ...
  } 
}
:endinlinecode 

h1. Self Types in Scala

_Self type declarations_, like this:

:inlinecode lang=scala, class=code-small
abstract class X11Window(properties: Properties) { 
  self: Rectangle =>
  ...
}
:endinlinecode 

are "promises" that any _concrete_ class eventually created from @X11Window@ will mix in a Rectangle trait. In byte code, it is identical to @X11Window extends Rectangle@, but avoids the _is a_ trap (Liskov).

h1. Self Types in Scala

In other words, we could write it this way:

:inlinecode lang=scala, class=code-small
abstract class X11Window(properties: Properties) extends Rectangle { 
  ...
}
:endinlinecode 

but that implies that window is substitutable for Rectangle (Liskov), which is a poor inheritance relationship. 

Self types emphasize instead that we will get the "Rectangle" behavior we need through a mixin.

h1. Instantiating the Objects

So, to create actual objects the factory method would do this:

:inlinecode lang=scala, class=code-small
object X11WindowFactory extends WindowFactory { 
  def make(properties: Properties) = {
    val dimensions = // get dimensions from properties
    new X11Window(dimensions) with utils.Logging with OGLRectangle {
      val lowerLeft = // get it from the dimensions
      val upperRight = // get it from the dimensions
    }
  } // returns window WITH Logging WITH OGLRectangle!
} 
:endinlinecode 

Note: this technique is called the "Cake Pattern":http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di.html (also discussed "here":http://programming-scala.labs.oreilly.com/ch13.html and used to "implement the Scala compiler itself":http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5834&rep=rep1&type=pdf)

h1. Problems with Objects

h1. Clone

h1. Equals

h1. Typing

h1. LSP revisited

Covariant and Contravariant behaviors.

h1. Concurrency

