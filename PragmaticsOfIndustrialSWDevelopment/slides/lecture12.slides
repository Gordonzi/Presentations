h1. Lecture 12: Complexity vs. Simplicity Part I: Effective Software Development Processes - Scrum, XP, and Lean

h1. Software Development Process

Ideally, a software development process helps us:

* Plan the project,
** Timeline, including the delivery schedule.
** Resources required.
** Itemize and prioritize the deliverables that will be created.
* Execute on the plan.
* Deliver on time and under budget.

h1. Project Planning

bq. If a project is truly innovative, you cannot possibly know its exact cost and exact schedule at the beginning.

<div class='cite'>-- John Gavin, Director of the Lunar Module Program, in an article in M.I.T.'s Technology Review, 1994, and quoted in his obituary on November 4, 2010 in the "New York Times":http://nyti.ms/a2yPRN.</div>

h1. Why Do We Plan?

We _really_ want to predict the future:

* Is the project feasible?
* What is the _real_ cost of a project?
** Will the _benefits_ outweigh the _costs_?
* Will the project finish on time to meet market needs and/or deadlines?

h1. Central Dilemma of Project Management

We can never have _perfect knowledge_ at the beginning of a project to know these answers.

* We can never think of every possible _contingency_.
* Events outside our control can upset our careful plans.
* We are _learning_ about the project as we do it.

h1. Plans vs. Reality, I

bq. No plan of operations extends with certainty beyond the first encounter with the enemy's main strength.

Or put more simply,

bq. No plan survives contact with the enemy.

<div class='cite'>-- Helmuth von Moltke the Elder, Chief of Staff of the Prussian Army for 30 years.</div>

h1. Plans vs. Reality, II

bq. Plans are nothing; planning is everything. 

<div class='cite'>-- General Dwight D. Eisenhower, Supreme Commander of Allied Forces, World War II.</div>

h1. Then, Why Bother With Planning?

Because we still need to get as close to the ideal goals as possible. So, project planning and processes have to address:

* Prioritizing features.
* Risk reduction strategies.
* Learning as you go.
* Feedback loops and iterations.

h1. Prioritizing Features

For every project, some features (requirements) are more important than others. Think about the evolution of mobile phones. While we love having email and web browsing on "smart" phones, it was important first for phones to make and receive calls! Voice mail and lists of phone numbers came next, etc.

A common mistake: _work on the stuff that's easiest or most fun first, rather than the stuff that's most important._

h1. Risk Reduction Strategies

_Contingency planning_ is a venerable technique for trying to anticipate every possible contingency and decide how it will be handled.

That usually translates to identification of potential risks and responses to them.

h1. Some Potential Risk

* Market changes.
* Technical aspects of the project are not yet understood.
* Technical aspects of the project prove not feasible.
* The pace of development is slower than anticipated.
* The cost of development is slower than anticipated.

h1. Risk Reduction

But no amount of "thinking" and planning can remove all risk. As the war quotes imply, you have to adapt as circumstances change. Perhaps the most important benefit of contingency planning is the way it prepares you to adapt as needed.

h1. Project Execution

* How do we get to working, delivered software that _meets the requirements_?
* How do we stay within budget and quality goals? 
* What artifacts must be delivered?
* What techniques help us achieve these goals?

h1. Delivery on Time and Under Budget

Suppose you're building the main stadium for the next Olympic games. You have an obvious hard deadline for completion. 

Still, what actually gets finished is somewhat flexible. You might cut back on the amenities and ornamentation, while you can't cut back on safety and facilities, like adequate rest rooms!

Similarly, even when there are hard deadlines for a software project, often the secondary features can be deferred until later.

h1. Qualities of an Effective Process

The need for feedback and "course correction" means that any successful software development process must embrace _iterative and incremental development_ (IID).

* *Iterative* - The process is divided into time increments (usually of fixed duration).
* *Incremental* - The features are implemented to completion one at a time, not all at once.

IID lets you
* Solicit feedback from "stakeholders".
* Deliver limited functionality earlier rather than later!

h1. Software Processes and Complexity

All successful products (not just software) release as early as possible with minimal, but essential features. Later, they expand (and sometimes grow bloated).

A universal principle, repeated over and over again, is that successful systems, processes, tools, etc. avoid _unnecessary_ complexity. 

h1. Kinds of Complexity

There are two kinds of complexity:

* *Essential* - Inherent in the problem domain. Unavoidable.
* *Accidental* - Complexity added to the implementation that is not necessary and is detrimental.
<br/><br/>

bq. Make everything as simple as possible,<br/>but not simpler. 

<div class='cite'>-- Albert Einstein</cite>

h1. Software Processes: A History

Let's look at two of the most influential concepts in the history of software process thinking.

* Waterfall Model of Software Development
* Rational Unified Process
* Agile Methodologies

h1. Waterfall Model of Software Development

<center>
  <img src="images/Waterfall.png"></img>
</center>

h1. Waterfall Model of Software Development

This process looks orderly, controlled, predictable. Real projects posses none of those qualities! Real projects require feedback, iteration, and incremental delivery of features.

The Waterfall Process resulted with a historical accident![1] During the 60s, many researches recognized the importance of iterative development. One paper was "Managing the Development of Large Software Systems", by Winston Royce, in Proceedings of IEEE Westcon. 

This paper started with an image similar to the one on the previous slide, but it went on to argue that such a process can't work, because feedback is required.

[1] Craig Larman, "Agile and Iterative Development: A Manager's Guide", pp 102-107.

h1. Waterfall Model of Software Development

Tragically, when the DoD decided to draft a standard for software development based on this paper, the author ignored the feedback aspects and focused on the top-down discussion. In part, this decision reflected other influential trends of the time. (Larman discusses this in detail.)

The result was a deeply flawed approach to development that became an influential standard around the world. It caused a lot of damage before it was overturned.

h1. Waterfall: What Was Missing

<center>
  <img src="images/WaterfallWithFeedback.png"></img>
</center>

h1. Process Science

In fact, feedback loops are a "Process 101" requirement. Pick any _other_ process or similar "throughput-oriented" sequence of events, such as manufacturing, chemical engineering, electrical circuits. All would _fail_ without feedback loops.

There are stories that software process experts were laughed at when they described waterfall to process experts in other fields.

h1. Successors to Waterfall

In the late 80s and 90s, successors emerged that restored the important roll of iterations and feedback. Most were also tied to OOP. 

Perhaps the most interesting and influential was the _Rational Unified Process_ (RUP).

h1. Rational Unified Process (RUP)

Many considered Rational Corporation to be the leading expert in software development through much of the 80s and 90s. The term _Unified_ was tied to the their _Unified Modeling Language_ (UML) that they created by merging the separate approaches of the _Three Amigos_: Grady Booch, James Rumbaugh, and Ivar Jacobson.

(Booch was one of the original employees. Rumbaugh and Jacobson joined in the mid-90s, after establishing their reputations independently.) 

h1. Rational Unified Process (RUP)

While RUP embraced IID, it treated each iteration as a mini Waterfall, with some requirements gathering, some design, and more implementation and testing.

This approach reflected concerns about the _cost of change_.

h1. Drawbacks of RUP - Cost of Change

A _cardinal rule_ at the time; the longer a defect (requirement error, design flaw, bug) goes undetected in a project, the more expensive it is to fix, because the cost of _rework_ goes up, the later in a project the defect is detected. In the most severe cases, such defects can even kill projects!

h1. Drawbacks of RUP - Cost of Change

While true to an extent, it had the practical affect of encouraging _waterfall thinking_ to persist:

* We _must_ get the requirements right first!
* We _must_ design the code before implementing it!
* If we do the above, the implementation will be _mechanical_, predictable, and (mostly) bug free!

(RUP wasn't alone in this thinking.)

h1. Drawbacks of RUP - Cost of Change

So, in practice, organizations following RUP (and similar approaches) were often actually doing waterfall development, while paying lip service to incremental and iterative development. For example, since Rational was a big advocate of modeling with UML, RUP strongly recommended design by modeling... 

Another symptom of this was the belief that long-range plans can and should be followed. When they weren't followed, it was considered a failure of the process.

h1. Drawbacks of RUP - Too Prescriptive

Because of this fear of defects (and let's face it, because it was a commercial product and they needed stuff to sell), RUP became a very prescriptive process with way too many _roles_ and _responsibilities_ identified for all kinds of minutiae.

You were supposed to _instantiate_ RUP for your situation, that is pick the roles and responsibilities that made sense for you.

Rational (and independent consultants) made a lot of money on training and _instantiating_ RUP.

h1. Drawbacks of RUP - Too Prescriptive

Also, there is a subset of the population that _likes_ the world to be prescriptive, to tell them what to believe, what to do, and when.

However, remember our generals? While armies have lots of roles and responsibilities, _successful_ armies also understand the need to be flexible, not rigid, to break out of the artificial boxes when needed.

h1. Strengths and Weaknesses of RUP

+ Recognized the importance of feedback and IID.
- Too prescriptive.
- Based on an incorrect understanding of the cost of change.

h1. Birth of the Agile Movement

At the end of the 90s, during the Internet bubble, it quickly became apparent to many people that the "state of the art" for software development was too bloated and inefficient.

h1. Birth of the Agile Movement

I worked for a few tech startups in that era that tried to use variations of RUP, because "that's what you're supposed to do". For example, we still tried to model what we were doing, which was stupid, in retrospect, given the rapidly changing marketplace and our attempts to find a successful niche...

h1. Birth of the Agile Movement

I worked for a few other organizations that knew enough to abandon UML modeling, etc., but they had no alternatives in mind. They simply adopted ad hoc techniques, like hiring QA departments to test the code after it was written. 

The result? Lots of end-of-project overtime to fix serious flaws; crises 24x7 as the poor quality code caused problems in production.

h1. Birth of the Agile Movement

But other practitioners explored _principled_, yet _efficient_ and _effective_ approaches to the inherent problems of software development.

That is, just because we were "on Internet time", it didn't mean all the old challenges mysteriously vanished!

h1. Agile Manifesto

In February, 2001, 17 leaders from various _lightweight methodology_ camps meet at the Snowbird Ski Resort. They wanted to look for and document shared principles and practices. Some later expressed surprise that they achieved what they did, given the tendency for people to cling to their own ideas.

They adopted the term _agile_ as an umbrella term for their shared philosophy of effective software development. They drafted a simple _agile manifesto_ to express that philosophy...

h1. Agile Manifesto

"We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:

* *Individuals* and *interactions* _over_ *processes* and *tools*
* *Working software* _over_ *comprehensive documentation*
* *Customer collaboration* _over_ *contract negotiation*
* *Responding to change* _over_ *following a plan*

That is, while there is value in the items on the _right_, we value the items on the _left more_."

h1. Authors: The Agile Manifesto

<div class="tiny">
|_.Name |_.Agile "School"[1] |
| Kent Beck | XP |
| Mike Beedle | Scrum |
| Arie van Bennekum| Dynamic Systems Development Method (DSDM) |
| Alistair Cockburn | Crystal |
| Ward Cunningham | Extreme Programming (XP) |
| Martin Fowler | Consultant[2] |
| James Grenning | XP |
| Jim Highsmith | Adaptive Software Development |

[1] The "named" Agile methodology this person is most associated with, at least at the time the manifesto was drafted.
[2] Not involved in the invention of any particular "named" Agile methodology.
</div>

h1. Authors: The Agile Manifesto (cont.)

<div class="tiny">
|_.Name |_.Agile "School"[1] |
| Andrew Hunt | Consultant, co-owner of the Pragmatic Programmers[2] |
| Ron Jeffries | XP |
| Jon Kern | Feature Driven Development (FDD) |
| Brian Marick | Consultant focused on software testing |
| Robert C. Martin | XP |
| Steve Mellor | Consultant[2] |
| Ken Schwaber | Scrum |
| Jeff Sutherland | Scrum |
| Dave Thomas | Consultant, co-owner of the Pragmatic Programmers[2] |

[1] The "named" Agile methodology this person is most associated with, at least at the time the manifesto was drafted.
[2] Not involved in the invention of any particular "named" Agile methodology.
</div>

h1. Three Agile Methods: Scrum, XP, and Lean
  
While there are several different agile methods, we'll discuss the three most popular.[1]

* *Scrum* - focuses on project management.
* *XP* - a complete, small-team approach, addressing project management and developer practices.
* *Lean* - inspired by Toyota Lean, "Just-in-Time" Manufacturing.

[1] See Highsmith's "Agile Software Development Ecosystems" for an excellent survey of all the agile methods as of 2002 ().

h1. Three Agile Methods: Scrum, XP, and Lean

I'll describe these three processes as they were originally conceived, using original terminology. Today, they have borrowed heavily from each other, so you'll encounter hybrid processes in most organizations.

h1. Scrum

Developed in the mid-90s. First public presentation at OOPSLA '95.

Named after the _scrum_ in Rugby, where a team huddle's together to move the ball down the field. It is used as a metaphor for the frequent, quick, daily _standup_ meetings done by teams and the philosophy that the whole team works together to deliver the software.

Why have meetings standing up? Because you get tired quickly, so you get them over with quickly!

h1. Scrum's Process

<center>
  <img src="images/800px-Scrum_process.png"></img>
</center>

h1. Scrum Terms and Concepts

<div class="small">
|_.Term |_.Definition|
| *Sprint* | A 30-day iteration, resulting in some increment of working software. |
| *Backlog* | A prioritized list of tasks, requirements, etc. to do. |
| *Product Backlog* | The full backlog for the whole project. |
| *Sprint Backlog* | The backlog just for the current *sprint*. |
| *Daily Scrum* | Daily stand up, each working day at the same time. Time boxed to _15 minutes_! |
| *Burn-down Chart* | Chart of finished tasks vs. time, trending to zero tasks left for the *sprint*. |
</div>

h1. Burn-down Chart

<center>
  <img src="images/800px-SampleBurndownChart.png"></img>
</center>

h1. Variation: Burn-up Chart

<center>
  <img src="images/iteration_burn_up.png"></img>
</center>

h1. Variation: Burn-up Chart

Better for showing project-wide statistics, since the "remaining" tasks may be increasing (feature creep!).

(We'll discuss _story points_ shortly.)

h1. Scrum Terms and Concepts (cont.)

<div class="small">
|_.Term |_.Definition|
| *Scrum Master* | Maintains the process, e.g., the backlogs. Also functions as the process coach, as needed. |
| *Product Owner* | The _stakeholder_ representative. Helps define and prioritize the work and reviews the results at the end of each *sprint*. |
| *Team* | A cross functional group, ideally under 10 people, who do everything from analysis to testing. |
</div>

h1. Life of a Sprint

A *sprint* starts with a *sprint planning meeting*, where the *scrum master* and *product owner* present the highest priority work left on the *project backlog* to the team. The team decides _for itself_ how much of the backlog it can complete in the next sprint. It usually captures this information in hour estimates. This meeting should not last more than 1/2 day.

Once the team as agreed on the *sprint backlog*, i.e., the work to be done in the sprint, the *sprint backlog* is _frozen_ for the whole sprint (except for extraordinary circumstances). This minimizes churn for the developers.

h1. Life of a Sprint

The team members decide amongst themselves who will do what work.

Each day, at the same time and place, they have a *daily scrum*, lasting no more than 15 minutes. Each team member answers three questions:

# What have you done since yesterday?
# What are you planning to do today?
# Do you have any problems preventing you from accomplishing your goal?

All other discussions are deferred until after the scrum.

h1. Life of a Sprint

The sprint ends with two meetings (often combined into one).

* *Sprint Review* - What was accomplished? Demo for *product owner*. Time boxed to 4 hours.
* *Sprint Retrospective* - What worked and didn't work in the last sprint? What can we do to improve going forward? Time boxed to 3 hours. 

h1. Life of a Sprint

_Wash, rinse, repeat..._

h1. Reading Assignment

* "JUnit Test Infected: Programmers Love Writing Tests":http://junit.sourceforge.net/doc/testinfected/testing.htm. An early and highly influential essay on TDD, written by Kent Beck, the creator of JUnit.

h1. A "Retrospective" on Scrum 

Scrum has been the first agile process adopted by many organizations - the _gateway drug_, if you will.

+ Focuses on program management issues - a good place to start.
+ Easy to grasp.
- 30 day sprints are now seen as too long (in most organizations).
- Ignored developer activities - which eventually undermine successes (e.g., due to lack of testing and poor quality).
- _Certified Scrum Master_ training became a "degree-mill" kind of embarrassment. The false sense of "achieved expertise" has led to many failed projects.

h1. Extreme Programming (XP)

Started with a now-famous project, a payroll system at Chrysler, written in Smalltalk, that began in 1996. Kent Beck brought on to do Smalltalk performance consulting, but he quickly introduced process improvements based on his prior work with Ward Cunningham. Ron Jeffries was also brought in as a consultant.

Beck wrote perhaps the most influential book on software process in the last decade, "Extreme Programming Explained: Embrace Change", 2nd Edition (2005). (This was a significant rewrite. If you can find it, it's worth reading the original edition, published in 2000.)

h1. Why Extreme?

bq. The first time I was asked to lead a team, I asked them to do a little bit of the things I thought were sensible, like testing and reviews. The second time there was a lot more on the line. I thought, "Damn the torpedoes, at least this will make a good article," [and] asked the team to crank up all the knobs to 10 on the things I thought were essential and leave out everything else.

<div class='cite'>-- Kent Beck in an interview he and Martin Fowler did with  "informit.com":http://www.informit.com/articles/article.aspx?p=20972.</div>

h1. Why Extreme? (cont.)

XP Tries to push ideas to their logical extreme.

* Hard to gather requirements? Put the customer in the same room.
* Is quality an issue? Push testing to _before_ coding.
* Designs hard to keep consistent with code? Design as you code.
* Documentation grows obsolete? Make the code, including the tests, be the documentation.

h1. Universal Themes

* Short, time-boxed iterations and incremental releases.
* Continuous customer feedback.
* Developer testing to virtually eliminate bugs.
* Whole-team collaboration and responsibility.

h1. Reading Assignment

* "JUnit Test Infected: Programmers Love Writing Tests."http://junit.sourceforge.net/doc/testinfected/testing.htm. An early and highly-influential essay on TDD, written by Kent Beck, who created JUnit.
* Kent Beck and Martin Fowler interview about XP with  "informit.com":http://www.informit.com/articles/article.aspx?p=20972.

h1. Reading Assignment (cont.)

last week, I had you read some general introductions to Agile. This week, I want you read about the three main Agile methodologies that we discussed today.

* "Scrum":http://en.wikipedia.org/wiki/Scrum_(development).
* "Extreme Programming":http://en.wikipedia.org/wiki/Extreme_Programming.
* "Lean Software Development":http://en.wikipedia.org/wiki/Lean_software_development.

h1. For Next Week: Simplicity and Systems.

* Eric Brewer, "Toward Robust, Distributed Systems":http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf. The keynote at the "ACM Symposium on Principles of Distributed Computing":http://www.podc.org/podc2000/ that introduced Brewer's CAP theorem. Focus on the first 2/3rds of the presentation (up to _The DQ Principle_.)

h1. Mini-Project

* Today: Turn in an outline of the specific items you will research and write up (for research projects) or implement (for coding projects). Also briefly describe what you have completed so far.
* 11/30: Turn in an refined outline and a summary of your progress so far.
* 12/5 (Sunday): Turn in a draft of your presentation slides for the 15-minute talk. (You can still work on them until Tuesday.)
* 12/7: Last class - presentations and turn in your writeup or code (GitHub preferred).
