<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>The Akka Framework</title>
<!-- metadata -->
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<meta name="presdate" content="20050728" />
<meta name="author" content="Eric A. Meyer" />
<meta name="author" content="Dean Wampler" />
<meta name="company" content="Complex Spiral Consulting" />
<meta name="company" content="DRW Holdings" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />
<link href="styles.css" media="all" rel="Stylesheet" type="text/css" />
<!-- Syntax highlighting -->
<script type="text/javascript" src="scripts/shCore.js"></script>
<script type="text/javascript" src="scripts/shBrushBash.js"></script>
<script type="text/javascript" src="scripts/shBrushCpp.js"></script>
<script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
<script type="text/javascript" src="scripts/shBrushCss.js"></script>
<script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
<script type="text/javascript" src="scripts/shBrushDiff.js"></script>
<script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
<script type="text/javascript" src="scripts/shBrushJava.js"></script>
<script type="text/javascript" src="scripts/shBrushJScript.js"></script>
<script type="text/javascript" src="scripts/shBrushPhp.js"></script>
<script type="text/javascript" src="scripts/shBrushPlain.js"></script>
<script type="text/javascript" src="scripts/shBrushPython.js"></script>
<script type="text/javascript" src="scripts/shBrushRuby.js"></script>
<script type="text/javascript" src="scripts/shBrushScala.js"></script>
<script type="text/javascript" src="scripts/shBrushSql.js"></script>
<script type="text/javascript" src="scripts/shBrushVb.js"></script>
<script type="text/javascript" src="scripts/shBrushXml.js"></script>
<link type="text/css" rel="stylesheet" href="styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="styles/shThemeDefault.css"/>
<script type="text/javascript">
	SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
	SyntaxHighlighter.all();
</script>
<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1>The Akka Framework: Strange-Loop: 10/15/2010</h1>
</div>

</div>


<div class="presentation">

<div class="slide">
<h1>The Akka Framework</h1>
<p class="subtitle">Simpler Scalability, Fault-Tolerance, <br/>Concurrency and Remoting through Actors</p>
<p class="subtitle">Dean Wampler</p>
<p class="subsubtitle">
dean@deanwampler.com, @deanwampler</p>
</div>


<div class="slide">
<h1 id="what_is_akka">What Is Akka?</h1>

<ul>
<li><a href="http://akkasource.org Akka">http://akkasource.org</a>
<ul>
<li>Source at <a href="http://github.com/jboner/akka GitHub">http://github.com/jboner/akka</a></li>
<li>Documentation at <a href="http://doc.akkasource.org Documentation">http://doc.akkasource.org</a></li>
</ul></li>
<li>A Scala and Java framework for scalability, fault-tolerance, concurrency and remoting through actors.</li>
<li>Inspired by Erlang OTP.</li>
<li>Started and led by Jonas Bon&#233;r.
<ul>
<li>Co-creator of AspectWerkz. </li>
<li>Worked on JRocket, Terracotta, and AspectJ.</li>
</ul></li>
</ul>
<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="highlights">Highlights</h1>

	<table class="table">
	  <tr><th><strong>Highlight</strong></th><th>Description</th></tr>
	  <tr><td><strong>Simpler Concurrency</strong></td><td>Write robust concurrent applications using Actors, STM &amp; Transactors (transactional actors).</td></tr>
	  <tr><td><strong>Event-driven Architecture</strong></td><td>The perfect platform for asynchronous, event-driven architectures. Never block.</td></tr>
	  <tr><td><strong>True Scalability</strong></td><td>Scale out on multi-core or multiple nodes using asynchronous message passing.</td></tr>
	</table>

  <p>(Adapted from the <a href="akkasource.org">http://akkasource.org</a> web site.)</p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="highlights">Highlights</h1>

	<table class="table">
	  <tr><th><strong>Highlight</strong></th><th>Description</th></tr>
	  <tr><td><strong>Fault Tolerance</strong></td><td><em>Embrace failure</em>. Write applications that self-heal using Erlang-style Actor supervisor hierarchies.</td></tr>
	  <tr><td><strong>Transparent Remoting</strong></td><td>Remote Actors give you a high-performance, transparent-distributed programming model.</td></tr>
	  <tr><td><strong>Scala <em>and</em> Java APIs</strong></td><td>Use Scala if you can, but if you can't, get the benefits in your existing Java apps!</td></tr>
	</table>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="organization">Actors</h1>

<table class="table">
  <tr><th><strong>Feature</strong></th><th>Description</th></tr>
  <tr><td><strong>Actors</strong></td><td>Core concurrency abstraction.</td></tr>
  <tr><td><strong>Transactors</strong></td><td>Actors with <em>transactional</em> behavior.</td></tr>
  <tr><td><strong>Remote&nbsp;Actors</strong></td><td>Horizontally distributed behavior.</td></tr>
</table>

<div class="handout">
</div>
</div>

<div class="slide">
<h1>But Wait, There's More!</h1>

<table class="table">
  <tr><th><strong>Feature</strong></th><th>Description</th></tr>
  <tr><td><strong>STM</strong></td><td><em>Software Transactional Memory</em>: the hotness made popular by Clojure. (Multiverse library)</td></tr>
  <tr><td><strong>Durable STM</strong></td><td>Redis, MongoDB, Cassandra, and more added regularly.</td></tr>
  <tr><td><strong>Microkernel</strong></td><td>A standalone kernel for running Akka-based applications, or deploy your app in an application server.</td></tr>
  <tr><td><strong>Security</strong></td><td>Adapted from Lift&#8217;s authentication module.</td></tr>
</table>
<div class="handout">
</div>
</div>

<div class="slide">
<h1>But Wait, There's More!</h1>

<table class="table">
  <tr><th><strong>Feature</strong></th><th>Description</th></tr>
  <tr><td><strong>REST</strong></td><td>Module for REST-ful web services.</td></tr>
  <tr><td><strong>Comet</strong></td><td>Module for Comet &#8220;persistent&#8221; connections.</td></tr>
  <tr><td><strong>AMQP</strong></td><td>Module for AMQP messaging.</td></tr>
</table>
<div class="handout">
</div>
</div>

<div class="slide">
<h1>But Wait, There's More!</h1>

<table class="table">
  <tr><th><strong>Feature</strong></th><th>Description</th></tr>
  <tr><td><strong>Spring, Guice, and Lift</strong></td><td>Integration modules for these frameworks.</td></tr>
  <tr><td><strong>Camel</strong></td><td>Module for the Apache Camel library, a DSL for routing definitions, Spring configuration definitions, <em>etc.</em></td></tr>
  <tr><td><strong>Samples</strong></td><td>For Security, REST, Chat, and Lift.</td></tr>
</table>

<div class="slide">
  <h1 id="akka_core">Actors</h1>

	<p><em>"Autonomous agents" coordinate work through message passing.</em></p>
	<ul>
  	<li>Actors can work in parallel.</li>
		<li>Provides an intuitive model for concurrency</li>
	</ul>
	
  <p>Originally developed by Hewitt in 1973. Made famous by Erlang. (Scala actor syntax is patterned after Erlang's)</p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="akka_core">Akka's Actor Library</h1>

  <p>Akka's actor library is independent of Scala&#8217;s standard actor API.</p>
	<ul>
  	<li>Simpler syntax.</li>
  	<li>Adds actor <em>supervision</em>, transactional behavior.</li>
  	<li>Significant performance improvements.</li>
  	<li>Can be "untyped" or "typed".</li>
  </ul>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="akka_core">Actor Supervision</h1>

	<img src="images/ActorSupervision1.svg"></img>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="akka_core">If an Actor Dies?</h1>

	<img src="images/ActorSupervision2.svg"></img>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Actor Life Cycle</h1>
  
	<table class="table">
	  <tr><th>Life Cycle</th><th>Description</th></tr>
	  <tr><td><code>Temporary</code></td><td>Do not restart the actor if it crashes.</td></tr>
	  <tr><td><code>Permanent</code></td><td>Restart the actor when necessary; keep it running permanently.</td></tr>
	</table>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="akka_core">Restart Strategy an Actor Dies?</h1>

	<table class="table">
	  <tr><th><strong>Strategy</strong></th><th>Description</th></tr>
	  <tr><td><strong>One for All</strong></td><td>Just restart the failed actor.</td></tr>
	  <tr><td><strong>All for One</strong></td><td>Restart all the actors.</td></tr>
	</table>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Erlang OTP-Style Supervisors</h1>

  <pre class="brush: scala;" style="font-size: 50%;">
	val supervisor = Supervisor(  
	  SupervisorConfig(
	    RestartStrategy(
	      AllForOne, 3, 1000, List(classOf[Exception])),
	    Supervise(
	      actorOf[Actor2],
	      Permanent) :: 
	    Supervise(
	      actorOf[Actor3],
	      Permanent) ::
	    Nil))
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Other Arguments for Controlling Restart</h1>

	<table class="table">
	  <tr><th>Description</th></tr>
	  <tr><td>The number of retries to attempt.</td></tr>
	  <tr><td>How long to wait between restart attempts.</td></tr>
	  <tr><td>What exceptions to intercept.</td></tr>
	</table>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Supervision and Fault Handling</h1>

  <p>Akka subscribes to the <em>Let It Fail</em> strategy:</p>

  <ul>
  <li>Don&#8217;t build complicated logic to attempt recovery when things go wrong.</li>
  <li>Distribute behavior among many actors.</li>
  <li>When one of them gets into trouble, kill it and restart it. </li>
  </ul>

  <p>It's easier to just drop a small piece of malfunctioning code. A big "wad" is <em>too big to fail...</em></p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="akka_core">Actors vs. ActorRefs</h1>

	<p>Like Clojure <code>refs</code>, Akka separates the <em>actor</em> from references to it.<p>
		
	<ul>
		<li>You send messages to the <code>ActorRef</code>.
		<li>If the <code>Actor</code> has to be restarted, the references are still valid.</li>
	</ul>
			
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>An Actor with an Init. Body and Message Handler</h1>

  <p>This example uses the <code>Actor</code> object&#8217;s <code>init</code> method to create an actor. (Eliding <code>se.scalablesolutions</code> prefixes...)</p> 

  <pre class="brush: scala;">
  import ...akka.actor.Actor._
  
  val a = Actor.init {
    ... // initializer block (optional)
  } receive {
    case message =&gt; ... // handle message 
  } 
  // "a" is of type ActorRef!
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Create and Wrap a Custom Actor Type</h1>

  <p>This example uses a custom <code>Actor</code> and the <code>actorOf</code> "static" method to create an instance and wrap it in a <code>ActorRef</code>.</p> 

  <pre class="brush: scala;">
	  import ...akka.actor.Actor._

		val actor2Ref = actorOf[Actor2]
		actor2Ref.start
  </pre>

or
	<pre class="brush: scala;">
		val actor2Ref = actorOf[Actor2].start
	</pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Spawn a Worker Task</h1>

  <p>When you don&#8217;t need to send it messages&#8230;</p>

  <pre class="brush: scala;">
  import ...akka.actor.Actor._

  spawn {
    ... // do stuff
  }
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Send an Asynchronous Message</h1>

  <pre class="brush: scala;">
  // Import Self when the current 
  // sender isn't an actor.
  import Actor.Sender.Self   
  
  actor ! "Hello"    // Fire and forget
  // Go about your business...
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Send a Synchronous Message</h1>

  <pre class="brush: scala;">
	  // fire and wait for a reply...
    (actor !! "Hello") match {  
      case Some(reply) => ... // handle reply
      case None =>        ... // handle timeout
    }
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Send Messages with Future Replies</h1>

  <pre class="brush: scala;">
  def pingAllActors(message: String) = {
    val allActors = ActorRegistry.actors
    try {
      val futures = allActors map { 
	      actor => actor !!! Ping(message) 
      }
      Futures.awaitAll(futures)
      handlePingRepliesIn(futures)
    } catch {
      case fte: FutureTimeoutException => ...
    }
  }
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Forward a Message</h1>

  <p>Retains the original sender.</p>

  <pre class="brush: scala;">
  actor.forward(message)
  </pre>
  

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>&#8220;HotSwap&#8221; - Replace an Actor&#8217;s Message Loop</h1>

  <p>Send a message <code>HotSwap</code> with the new <code>PartialFunction</code> defining the new message loop for the Actor.</p>

  <pre class="brush: scala;">
  actor ! HotSwap(Some({
    case message =&gt; println("Hotswapped body...")
  }))
  </pre>


<div class="handout">
</div>
</div>

<div class="slide">
  <h1>&#8220;HotSwap&#8221; - Rollback to Previous Version</h1>

  <p>The old version is kept so you can rollback by sending <code>HotSwap</code> with <code>None</code>.</p>

  <pre class="brush: scala;">actor ! HotSwap(None)
  </pre>

  <p>The original actor theory included this idea!</p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>STM</h1>

  <p><em>Software Transactional Memory</em> (STM) is the application of ACID (minus the D) transactional semantics to memory. It has been popularized by Clojure, of course.</p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>STM: Based on 2 Concepts</h1>

  <ul>
    <li><strong>Managed References</strong></li>
    <li><strong>Persistent Data Structures</strong></li>
	</ul>
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Managed References</h1>

  <p>Memory cells hold an immutable value. CAS (Compare-And-Swap) semantics are enforced by the STM to coordinate changes across many References.</p>

	<img src="images/Refs.svg"></img>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Persistent Data Structures</h1>

	<img src="images/Tree1.svg"></img>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Persistent Data Structures</h1>

	<img src="images/Tree2.svg"></img>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Persistent Data Structures</h1>

  <ul>
		<li><strong>Immutable</strong>, but with fast access and modification times, due to structural sharing.</li>
		<li><strong>Persistent</strong>, because no modification affects the original structure.</li>
	</ul>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Akka's Persistent Collections</h1>

  <p>Remember that <em>persistent</em> doesn't mean <em>written to a database</em>. It means that older versions are not lost when newer instances are created (until garbage collected).</p>

  <table class="table">
    <tr><th>Data Structure</th><th>Description</th></tr>
    <tr><td><code>PersistentMap</code></td><td>Implements <code>scala.collection.mutable.Map</code></td></tr>
    <tr><td><code>PersistentVector</code></td><td>Implements <code>scala.RandomAccessSeq</code></td></tr>
    <tr><td><code>PersistentRef</code></td><td>Compare and Set (CAS) cell</td></tr>
  </table>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Akka's STM: Implementation</h1>

  <p>Akka&#8217;s persistent Map and Vector are ports of Clojure&#8217;s Map and Vector.</p>

	<p>The Managed References are implemented using the <a href="http://code.google.com/p/multiverse/ Multiverse STM">Java Multiverse STM</a>.</p>
	
	<p>(Scala's standard library will have its own STM API eventually.)

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Akka's STM: Durability?</h1>

  <p>Akka provides backend durability, if desired, using <strong>MongoDB</strong>, <strong>Cassandra</strong>, <strong>Redis</strong>, and more.</p>

	<p>(These Akka APIs are not intended for general persistence needs.)</p>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Transactors: Transactions + Actors</h1>

  <p><strong>Transactors</strong> combine <strong>Actors</strong>, which provide concurrency and asynchronous event-based programming, and <strong>STM</strong>, which provides compositional, transactional, state management. Hence, transactors provide transactional, compositional, asynchronous, event-based message flows.</p>

  <p>There are several ways to impose &#8220;transaction required&#8221; semantics:</p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Extend the <code>Transactor</code> Trait</h1>

  <pre class="brush: scala;">
  import ...akka.actor.Transactor

  class MyActor extends Transactor {
    ...
  }
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Mix in the <code>TransactionRequired</code> Trait</h1>

  <pre class="brush: scala;">
  class MyActor extends Actor 
     with TransactionRequired {
    ...
  }

  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1><code>makeTransactionRequired</code> Method</h1>

  <pre class="brush: scala;">
  class MyActor extends Actor {
    makeTransactionRequired
    ...
  }
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">

<h1>Persistent Data Structs in a Transactor</h1>

<p><strong>Tip:</strong> If you create a transactional <code>Ref</code>, <code>Vector</code> or <code>Map</code> in a <code>Transactor</code> constructor, either declare it <code>lazy</code>, to ensure that it is created within the scope of a transaction, or create the data structure inside an <code>atomic { ... }</code> block.</p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Other Core Actor Modules</h1>

	<p>I'll just to mention these.</p>
	
  <table class="table">
    <tr><th>Module</th><th>Description</th></tr>
    <tr><td><strong>Remote Actors</strong></td><td>Mostly-transparent remote message passing.</td></tr>
    <tr><td><strong>Dispatcher</strong></td><td>Configure and optimize the messaging infrastructure, <em>etc.</em></td></tr>
	</table>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Other Core General Modules</h1>

	<p>I'll just to mention these, too.</p>
	
  <table class="table">
    <tr><th>Module</th><th>Description</th></tr>
    <tr><td><strong>Serialization</strong></td><td>JSON, Protocol Buffers, and SBinary.</td></tr>
    <tr><td><strong>Configuration</strong></td><td>Conventional text-based configuration files.</td></tr>
    <tr><td><strong>Cluster Membership</strong></td><td>JGroups (P2P), Shoal (also P2P + JXTA), ZooKeeper (planned).</td></tr>
  </table>


<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Microkernel Module</h1>

  <ol>
    <li>To start the kernel invoke:
      <ul><li><code>java -jar $AKKA_HOME/dist/akka-&lt;version&gt;.jar</code></li></ul>
    </li>
    <li>Wait for all services to start up.</li>
    <li>Profit!</li>
  </ol>

	<p>(Doesn't support a full web stack. Use Jetty...)</p>
	
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Configuration</h1>

  <p>The kernel will look for a configuration file <code>akka.conf</code>, <em>e.g.,</em> in <code>$AKKA_HOME/config/akka.conf</code> or on the <code>CLASSPATH</code>.</p>

  <p>Some of the things you can configure:</p>

  <ul>
    <li>Logging.</li>
    <li>Actor and STM default properties.</li>
    <li>Persistence store properties.</li>
    <li>Server and client hostnames and ports.</li>
    <li>&#8230;</li>
  </ul>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Persistence Module</h1>
  <p>Instances of persistent data structures can be backed by one of several (and growing) supported <em>NoSQL</em> datastores:</p>

  <ul>
  <li>Cassandra</li>
  <li>Redis</li>
  <li>MongoDB</li>
  <li>CouchDB</li>
  <li>...</li>
  </ul>


<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Cassandra Example (1/5)</h1>

  <p>Requires an Akka configuration file, e.g., <code>akka.conf</code>, for details like the host and port, and a Cassandra configuration file <code>storage-conf.xml</code>.</p>

  <p>Create one of the persistent data structures:</p>

  <pre class="brush: scala;">
  val map = CassandraStorage.newMap(id)
  val vector = CassandraStorage.newVector(id)
  val ref = CassandraStorage.newRef(id)
  </pre>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Cassandra Example (2/5)</h1>

  <p>Retrieve a persistent data structure based on an explicit id (will be created if it doesn&#8217;t exist):</p>

  <pre class="brush: scala;">
  val map = CassandraStorage.getMap(id)
  val vector = CassandraStorage.getVector(id)
  val ref = CassandraStorage.getRef(id)
  </pre>


<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Cassandra Example (3/5)</h1>

  <p>Akka also provides a direct Cassandra API. It abstracts away session pooling, protocol <em>etc.</em> and lets us by-pass the STM persistence abstractions (Map, Vector and Ref). </p>

  <pre class="brush: scala;">
    import ...akka.state.CassandraSessionPool

    val sessions = new CassandraSessionPool(
      keyspace,
      StackPool(SocketProvider(hostname, port)),
      protocol,
      ConsistencyLevel.QUORUM)
    ...
  </pre>


<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Cassandra Example (4/5)</h1>

  <pre class="brush: scala;">
    ...

    // insert a column
    sessions.withSession { session =&gt;
      session ++| (key, new ColumnPath(columnFamily, null, columnName), 
                   serializer.out(element), System.currentTimeMillis)
    }
    ...
  </pre>


<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Cassandra Example (5/5)</h1>

  <pre class="brush: scala;">
    ...
    // retrieve a column
    val column: Option[ColumnOrSuperColumn] = sessions.withSession { session =&gt;
      session | (key, new ColumnPath(columnFamily, null, columnName))
    }

    // get a range of colums
    val columns: List[ColumnOrSuperColumn] = sessions.withSession { session =&gt;
      session / (key, columnParent, slicePredicate, isAscending, count)
    }
  </pre>


<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Persistence Module: MongoDB and Redis</h1>
  <p>There are similar APIs for the other databases, with various levels of "completeness".</p>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="highlights">Recap (1/2)</h1>

  <ul>
    <li><b>Simpler Concurrency</b>: Write simpler concurrent (yet correct) applications using Actors, STM &amp; Transactors (transactional actors).</li>

    <li><b>Event-driven Architecture</b>: The perfect platform for asynchronous, event-driven architectures. Never block.</li>

    <li><b>True Scalability</b>: Scale out on multi-core or multiple nodes using asynchronous message passing.</li>
  </ul>

<div class="handout">
</div>
</div>

<div class="slide">
  <h1 id="highlights">Recap (2/2)</h1>

  <ul>
    <li><b>Fault-tolerance</b>: Embrace failure. Write applications that self-heal using Erlang-style Actor supervisor hierarchies.</li>

    <li><b>Transparent Remoting</b>: Remote Actors give you a high-performance, transparent-distributed programming model.</li>

    <li><b>Scala and Java APIs</b>: Scala and Java APIs, as well as integration with numerous 3rd-party APIs, like Spring. Deploy in your application server or run it stand-alone.</li>
  </ul>

<div class="handout">
</div>
</div>

<div class="slide book-logo">
  <h1>Buy My Book!</h1>

	<img src="images/ProgrammingScalaCoverSmall.jpg"></img>
			
<div class="handout">
</div>
</div>

<div class="slide">
  <h1>Thanks!</h1>

	<ul>
		<li><a href="akkasource.org">http://akkasource.org</a></li>
		<li><a href="mailto:dean@deanwampler.com">dean@deanwampler.com</a></li>
		<li><a href="http://twitter.com/deanwampler">@deanwampler</a> (Twitter)</li>
		<li><a href="http://polyglotprogramming.com/talks">polyglotprogramming.com</a></li>
	</ul>

<div class="handout">
</div>
</div>
<!-- insert new slides here -->

</div>

</body>
</html>
